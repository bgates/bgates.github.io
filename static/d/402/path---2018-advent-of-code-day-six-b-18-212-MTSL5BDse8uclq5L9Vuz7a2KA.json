{"data":{"mdx":{"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2019-05-05\",\n  \"order\": 7,\n  \"title\": \"Again with the Geometry\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"These geometry problems are tough.\"), mdx(\"h2\", null, \"The Problem\"), mdx(\"p\", null, \"This is best explained by the Advent of Code site itself, so I'm going to copy.\"), mdx(\"p\", null, \"For example, consider the following list of coordinates:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"1, 1\\n1, 6\\n8, 3\\n3, 4\\n5, 5\\n8, 9\\n\")), mdx(\"p\", null, \"If we name these coordinates A through F, we can draw them on a grid, putting 0,0 at the top left:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"..........\\n.A........\\n..........\\n........C.\\n...D......\\n.....E....\\n.B........\\n..........\\n..........\\n........F.\\n\")), mdx(\"p\", null, \"This view is partial - the actual grid extends infinitely in all directions. Using the Manhattan distance\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-manhattan\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-manhattan\",\n    \"className\": \"footnote-ref\"\n  }), \"manhattan\")), \", each location's closest coordinate can be determined, shown here in lowercase:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"aaaaa.cccc\\naAaaa.cccc\\naaaddecccc\\naadddeccCc\\n..dDdeeccc\\nbb.deEeecc\\nbBb.eeee..\\nbbb.eeefff\\nbbb.eeffff\\nbbb.ffffFf\\n\")), mdx(\"p\", null, \"Locations shown as . are equally far from two or more coordinates, and so they don't count as being closest to any.\"), mdx(\"p\", null, \"The goal is to find the coordinate that has the largest finite (that is, not infinite) number of spaces that are closer to it than to any of the other coordinates.\"), mdx(\"h2\", null, \"The Solution\"), mdx(\"p\", null, \"It starts with the usual data read, plus a bit of processing to turn each line into an array of two numbers:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nlet input = fs\\n  .readFileSync(`./input/day6.txt`, 'utf8')\\n  .trim()\\n  .split('\\\\n')\\n  .map(line => line.split(', ').map(Number))\\n\")), mdx(\"p\", null, \"This goes a bit against my philosophy of always preferring objects over arrays to store data unless there's a good reason to choose arrays. In this case my reason was that arrays seemed just a little bit easier.\"), mdx(\"p\", null, \"Then gather all the x values and all the y values and find maxes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const xMax = Math.max(...input.map(([x, y]) => x))\\nconst yMax = Math.max(...input.map(([x, y]) => y))\\n\")), mdx(\"h2\", null, \"Clearly a Bad idea\"), mdx(\"p\", null, \"At first I thought I would have to iterate over the whole grid, measuring the distance from each point on the grid to the nearest point from the input. That was going to be a lot of calculation; the grid is about 350x350, meaning over a million points, and there are about 250 points in the input list. I didn't see an obvious solution for deciding which input was closest to a given grid point without calculating every distance.\"), mdx(\"h2\", null, \"So Many Questions\"), mdx(\"p\", null, \"Instead I decided to measure outward, starting at each input point and finding its neighboring points, then all the neighbors of those points, etc. I would sort of build concentric circles around each input point, and each loop through the code would increase the radius of the circles. How would I know when to stop looping? I had no idea. What would I do when the expanding circles around each input point started to overlap? Not sure. What did I know how to do? Well, given a point, I could find the four points adjacent to it, and check to find which of them were on the grid:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const findNeighbors = ([x, y]) => {\\n  let prospects = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]\\n  return prospects.filter(\\n    ([X, Y]) => X >= 0 && Y >= 0 && X <= xMax && Y <= xMax\\n  )\\n}\\n\")), mdx(\"h2\", null, \"On to Data Storage\"), mdx(\"p\", null, \"Once I found the nearest neighbors for an coordinate, I'd need to store them somewhere. An object didn't seem like the right answer, because there was no clear candidate for a key to associate with each value. The other option was an array.\"), mdx(\"h3\", null, \"A Confession\"), mdx(\"p\", null, \"I tried to solve the Advent of Code problems, and write up these explanations, as the problems came available, during December 2018. I got almost all of the problems done on the day they were released. I wrote up most of the explanations as soon as I had the solutions. Apparently for this problem, my explanation write up got as far as the end of the last paragraph. I haven't touched this write up since December 7, 2018. It is now May 5, 2019. The rest of this explanation is going to be an attempt to recreate my thoughts based on my code.\"), mdx(\"h2\", null, \"Back to Data Storage\"), mdx(\"p\", null, \"I want to store all of the coordinates that are nearest to each of the coordinates in the input list. The problem with using an object to store each neighbor by itself is figuring out the right key. Suppose I wanted all the neighbors for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[1, 1]\"), \", which would include the points \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0, 1]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[2, 1]\"), \". I couldn't do something like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{ \\\"1, 1\\\": [0, 1], \\\"1, 1\\\": [2, 1] }\\n\")), mdx(\"p\", null, \"because the keys in an object have to be unique. Another option would be to store everything in an object, but have each value be an array of the points closest to the coordinate represented by the key. Taking the above example, the data structure would look like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{ \\\"1, 1\\\": [ [0, 1], [2, 1] ] }\\n\")), mdx(\"p\", null, \"The key is a coordinate from the input list, the value is an array, and each element of that array is a point closer to the coordinate key than to any other coordinate in the input list.\"), mdx(\"p\", null, \"That didn't seem quite right either. I was pretty sure I wanted to work with expanding concentric circles around each input coordinate. In order to build the next concentric circle, it would help to know where the last concentric circle was. To do that, I should store all of the points that made up each \\\"circle\\\" together in the data structure, without mixing all of the coordinates from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"every\"), \" \\\"circle\\\" together. I finally settled on something like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const concentricCircles = {\\n  \\\"key representing an input coordinate\\\": [\\n    [ /* the input coordinate itself */ ],\\n    [ /* the points 1 space out from the coordinate */ ],\\n    [ /* the points 2 spaces out from the coordinate */ ],\\n    ...\\n  ]\\n}\\n\")), mdx(\"p\", null, \"My strategy would be to create a loop, which would:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"iterate over the input coordinates\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"find the array associated with each coordinate, in my data structure\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"take the last element of that array, representing the biggest concentric circle so far\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"build a new concentric circle using that (somehow)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"stop expanding a circle when I detected I was running into another coordinate's neighbors (somehow)\")), mdx(\"p\", null, \"and then stop the overall loop (somehow). \\\"Strategy\\\" is perhaps too strong a word.\"), mdx(\"h2\", null, \"Creating a Starting Point\"), mdx(\"p\", null, \"I could start my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"concentricCircles\"), \" object by associating each input coordinate with an empty array, to hold the concentric circles around the coordinate. The first element of that array would be an array containing the center of the circles: the coordinate itself.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let concentricCircles = input.reduce((total, current) => {\\n  total[current] = []\\n  total[current][0] = [current]\\n  return total\\n}, {})\\n\")), mdx(\"h2\", null, \"Beginning by Hand\"), mdx(\"p\", null, \"I could start creating the concentric circles \\\"by hand\\\", without an ongoing loop, by iterating over the input coordinates. I can use my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"findNeighbors\"), \" function from a while ago to get the neighbors of each input coordinate, and store them in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"concentricCircles\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const findNeighbors = ([x, y]) => {\\n  let prospects = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]\\n  return prospects.filter(\\n    ([X, Y]) => X >= 0 && Y >= 0 && X <= xMax && Y <= xMax\\n  )\\n}\\ninput.forEach(point => {\\n  const neighbors = findNeighbors(point)\\n  concentricCircles[point][1] = neighbors\\n})\\n\")), mdx(\"p\", null, \"That gets me one \\\"circle\\\" around each of my input coordinates. Let me draw one example to remind you why I use quote marks when I talk about a \\\"circle\\\" using Manhattan distances. The \\\"0\\\" marks the center, and all the \\\"1\\\"s form the \\\"circle\\\":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \".....\\n..1..\\n.101.\\n..1..\\n.....\\n\")), mdx(\"p\", null, \"Since diagonal movement isn't allowed, only those four places are part of the first \\\"circle\\\". Now I'll add the next \\\"circle\\\":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"..2..\\n.212.\\n21012\\n.212.\\n..2..\\n\")), mdx(\"p\", null, \"It was pretty straightforward to use JavaScript to calculate where all the \\\"1\\\"s should go: they are all of the neighbors of the \\\"0\\\". But how can we calculate where all of the \\\"2\\\"s should go? That takes a few steps:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"take \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"all\"), \" of the \\\"1\\\"s\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"find all of \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"their\"), \" neighbors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"without double-counting (because some \\\"2\\\"s are neighbor to two \\\"1\\\"s)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and excluding the \\\"0\\\" (which is a neighbor to all the \\\"1\\\"s but is obviously not a \\\"2\\\")\")), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-manhattan\"\n  }), \"calculate the distance as though you were walking in a city - diagonal movement isn't allowed, because there are buildings in the way.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-manhattan\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","slug":"/2018-advent-of-code-day-six/","timeToRead":3,"wordCount":806,"frontMatter":{"date":"2019-05-05","title":"Again with the Geometry","tags":["education","javascript","Advent of Code"]},"prev":{"id":"c46df0df-2d72-5d4d-bbcc-07440881ed2d","parent":{"name":"2018-advent-of-code-day-five"},"excerpt":"The Problem There is a ( really  long) string made up of a mix of uppercase and lowercase letters. The string is to be shortened by removing…","fields":{"slug":"/2018-advent-of-code-day-five/"},"timeToRead":2,"wordCount":{"words":508},"frontmatter":{"date":"2019-05-05","title":"That's React_ion_, not React","tags":["education","javascript","Advent of Code"]}},"next":{"id":"b7118581-8cfd-5918-8049-7800ffaeba3c","parent":{"name":"2018-advent-of-code-day-one"},"excerpt":"2018 Advent of Code, Day One Advent of Code  is a series of software puzzles released every year during Advent ^advent . There's a cute…","fields":{"slug":"/2018-advent-of-code-day-one/"},"timeToRead":4,"wordCount":{"words":1158},"frontmatter":{"date":"2019-05-04","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]}}}}