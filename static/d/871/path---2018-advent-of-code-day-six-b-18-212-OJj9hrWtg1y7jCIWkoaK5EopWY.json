{"data":{"mdx":{"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2019-05-05\",\n  \"order\": 7,\n  \"title\": \"Again with the Geometry\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"These geometry problems are tough.\"), mdx(\"h2\", null, \"The Problem\"), mdx(\"p\", null, \"This is best explained by the Advent of Code site itself, so I'm going to copy.\"), mdx(\"p\", null, \"For example, consider the following list of coordinates:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"1, 1\\n1, 6\\n8, 3\\n3, 4\\n5, 5\\n8, 9\\n\")), mdx(\"p\", null, \"If we name these coordinates A through F, we can draw them on a grid, putting 0,0 at the top left:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"..........\\n.A........\\n..........\\n........C.\\n...D......\\n.....E....\\n.B........\\n..........\\n..........\\n........F.\\n\")), mdx(\"p\", null, \"This view is partial - the actual grid extends infinitely in all directions. Using the Manhattan distance, each location's closest coordinate can be determined, shown here in lowercase:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"aaaaa.cccc\\naAaaa.cccc\\naaaddecccc\\naadddeccCc\\n..dDdeeccc\\nbb.deEeecc\\nbBb.eeee..\\nbbb.eeefff\\nbbb.eeffff\\nbbb.ffffFf\\n\")), mdx(\"p\", null, \"Locations shown as . are equally far from two or more coordinates, and so they don't count as being closest to any.\"), mdx(\"p\", null, \"The goal is to find the coordinate that has the largest finite (that is, not infinite) number of spaces that are closer to it than to any of the other coordinates.\"), mdx(\"h2\", null, \"The Solution\"), mdx(\"p\", null, \"It starts with the usual data read, plus a bit of processing to turn each line into an array of two numbers:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nlet input = fs\\n  .readFileSync(`./input/day6.txt`, 'utf8')\\n  .trim()\\n  .split('\\\\n')\\n  .map(line => line.split(', ').map(Number))\\n\")), mdx(\"p\", null, \"This goes a bit against my philosophy of always preferring objects over arrays to store data unless there's a good reason to choose arrays. In this case my reason was that arrays seemed just a little bit easier.\"), mdx(\"p\", null, \"Then gather all the x values and all the y values and find maxes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const xMax = Math.max(...input.map(([x, y]) => x))\\nconst yMax = Math.max(...input.map(([x, y]) => y))\\n\")), mdx(\"p\", null, \"At first I thought I would have to iterate over the whole grid, measuring the distance from each point on the grid to the nearest point from the input. That was going to be a lot of calculation; the grid is about 350x350, meaning over a million points, and there are about 250 points in the input list. I didn't see an obvious solution for deciding which input was closest to a given grid point without calculating every distance.\"), mdx(\"h2\", null, \"Working Without a Plan\"), mdx(\"p\", null, \"Instead I decided to measure outward, starting at each input point and finding its neighboring points, then all the neighbors of those points, etc. I would sort of build concentric circles around each input point, and each loop through the code would increase the radius of the circles. How would I know when to stop looping? I had no idea. What would I do when the expanding circles around each input point started to overlap? Not sure. What did I know how to do? Well, given a point, I could find the four points adjacent to it, and check to find which of them were on the grid:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const findNeighbors = ([x, y]) => {\\n  let prospects = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]\\n  return prospects.filter(\\n    ([X, Y]) => X >= 0 && Y >= 0 && X <= xMax && Y <= xMax\\n  )\\n}\\n\")), mdx(\"p\", null, \"Once I found the nearest neighbors for an input, I'd need to store them somewhere. An object didn't seem like the right answer, because there was no clear candidate for a key to associate with each value. The other option was an array\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","slug":"/2018-advent-of-code-day-six/","timeToRead":1,"wordCount":271,"frontMatter":{"date":null,"title":"","tags":null},"prev":null,"next":{"id":"62e66597-dc96-5fc0-ad59-668577c3e85f","parent":{"name":"2018-advent-of-code-day-seven"},"excerpt":"This one really killed me. The problem was that I assumed every letter that didn't have a prerequisite would go to the start of the listâ€¦","fields":{"slug":"/2018-advent-of-code-day-seven/"},"timeToRead":1,"wordCount":{"words":389},"frontmatter":{"date":null,"title":"","tags":null}}}}