{"data":{"mdx":{"id":"62e66597-dc96-5fc0-ad59-668577c3e85f","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This one really killed me. The problem was that I assumed every letter that didn't have a prerequisite would go to the start of the list, instead of just taking the first letter with no prerequisite and then seeing what letter could come second. But I'm getting ahead of myself (again).\"), mdx(\"p\", null, \"There are two letters on each line, which I can extract by regular expressions:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nlet input = fs.readFileSync(`./input/day7.txt`, 'utf8')\\n  .trim()\\n  .split(\\\"\\\\n\\\")\\n  .map(line => [line.match(/Step (.)/)[1], line.match(/step (.)/)[1]])\\n\")), mdx(\"p\", null, \"Those letters represent a letter in the sequence and one that must come before it (a predecessor). I don't have a strategy at this point, but I think it will be useful to gather together all of the predecessors for each letter by iterating over all the input:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const predecessorsPerLetter = input.reduce((object, current) => {\\n  [ predecessor, letter ] = current\\n  if (object[letter]) {\\n    object[letter].push(predecessor)\\n  } else {\\n    object[letter] = [predecessor]\\n  }\\n  return object\\n}, {})\\n\")), mdx(\"p\", null, \"There must be a letter with no predecessors, to serve as the starting point for the sequence. To find it, I reduce all the predecessor arrays to just one, sort it, and filter to remove duplicates:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const letters = Object.values(predecessorsPerLetter)\\n  .reduce((all, current) => [ ...all, ...current ])\\n  .sort()\\n  .filter((letter, i, arr) => i === 0 || letter !== arr[i - 1])\\n\")), mdx(\"p\", null, \"The keys of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"predecessorsPerLetter\"), \" object are the letters that have predecessors. I can find a letter that's not part of that group to use as the starting point for the sequence:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const lettersWithPredecessors = Object.keys(predecessorsPerLetter)\\nconst startingPoint = letters\\n  .find(letter => !lettersWithPredecessors.includes(letter))\\nlet sequence = [startingPoint]\\n\")), mdx(\"p\", null, \"Next I have to find the letters that could potentially be added to the sequence, given the letters that are already part of the sequence. A letter is qualified to be added if every one of its predecessors is already part of the sequence (and if it hasn't been added to the sequece already). I sort the options because if there is more than one, I'm supposed to choose the one that comes first alphabetically:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const optionSelector = sequence => lettersWithPredecessors\\n  .filter(letter => !path.includes(letter))\\n  .filter(letter => (\\n    predecessorsPerLetter[letter].every(predecessor => (\\n      sequence.includes(predecessor)\\n    ))\\n  ))\\n  .sort()\\nlet options = optionSelector(sequence)\\n\")), mdx(\"p\", null, \"At that point I can start looping and adding letters to the sequence until there are no more letters to be added:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"while (options.length > 0) {\\n  sequence.push(options[0])\\n  options = optionSelector(sequence)\\n}\\n\")), mdx(\"p\", null, \"...aaaaand that doesn't quite work. I had assumed that there was only one letter with no predecessor. There are a few. I tried to clean that up like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const startingSequence = letters\\n  .find(letter => !lettersWithPredecessors.includes(letter))\\nlet sequence = startingSequence\\n\")), mdx(\"p\", null, \"...and I got stuck there for a few hours. Everything seemed to check out. My final sequence was the right length. I even tested my answer vs the input conditions, with\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"console.log(input.every(([predecessor, letter]) => {\\n  return sequence.indexOf(predecessor) < sequence.indexOf(letter) \\n}))\\n\")), mdx(\"p\", null, \"-but to no avail. Eventually I realized that my mistake was putting all of the letters that needed no predecessors at the start of the sequence, instead of treating them as \\\"wild cards\\\" that could be inserted whenever one of them was the best option.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const wildCards = predecessors\\n  .filter(letter => !lettersWithPredecessors.includes(letter))\\n\\nconst optionSelector = sequence => lettersWithPredecessors\\n  .concat(wildCards)\\n  .filter(letter => !path.includes(letter))\\n  .filter(letter => (\\n    !predecessorsPerLetter[letter] ||\\n    predecessorsPerLetter[letter].every(predecessor => (\\n      path.includes(predecessor)\\n    ))\\n  ))\\n  .sort()\\nlet path = [wildCards[0]]\\nlet options = optionSelector(path)\\n\")), mdx(\"p\", null, \"With those change, part one is complete.\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"62e66597-dc96-5fc0-ad59-668577c3e85f","slug":"/2018-advent-of-code-day-seven/","timeToRead":1,"wordCount":389,"frontMatter":{"date":null,"title":"","tags":null},"prev":{"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","parent":{"name":"2018-advent-of-code-day-six"},"excerpt":"These geometry problems are tough. It starts with the usual data read, plus a bit of processing to turn each line into an array of two…","fields":{"slug":"/2018-advent-of-code-day-six/"},"timeToRead":1,"wordCount":{"words":271},"frontmatter":{"date":null,"title":"","tags":null}},"next":{"id":"b7118581-8cfd-5918-8049-7800ffaeba3c","parent":{"name":"2018-advent-of-code-day-one"},"excerpt":"2018 Advent of Code, Day One Advent of Code  is a series of software puzzles released every year during Advent ^advent . There's a cute…","fields":{"slug":"/2018-advent-of-code-day-one/"},"timeToRead":4,"wordCount":{"words":1158},"frontmatter":{"date":"2019-05-04","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]}}}}