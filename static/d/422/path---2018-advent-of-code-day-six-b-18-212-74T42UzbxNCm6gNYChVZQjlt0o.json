{"data":{"mdx":{"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2019-05-05\",\n  \"order\": 7,\n  \"title\": \"Again with the Geometry\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"These geometry problems are tough.\"), mdx(\"h2\", null, \"The Problem\"), mdx(\"p\", null, \"This is best explained by the Advent of Code site itself, so I'm going to copy.\"), mdx(\"p\", null, \"For example, consider the following list of coordinates:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"1, 1\\n1, 6\\n8, 3\\n3, 4\\n5, 5\\n8, 9\\n\")), mdx(\"p\", null, \"If we name these coordinates A through F, we can draw them on a grid, putting 0,0 at the top left:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"..........\\n.A........\\n..........\\n........C.\\n...D......\\n.....E....\\n.B........\\n..........\\n..........\\n........F.\\n\")), mdx(\"p\", null, \"This view is partial - the actual grid extends infinitely in all directions. Using the Manhattan distance, each location's closest coordinate can be determined, shown here in lowercase:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"aaaaa.cccc\\naAaaa.cccc\\naaaddecccc\\naadddeccCc\\n..dDdeeccc\\nbb.deEeecc\\nbBb.eeee..\\nbbb.eeefff\\nbbb.eeffff\\nbbb.ffffFf\\n\")), mdx(\"p\", null, \"Locations shown as . are equally far from two or more coordinates, and so they don't count as being closest to any.\"), mdx(\"p\", null, \"The goal is to find the coordinate that has the largest finite (that is, not infinite) number of spaces that are closer to it than to any of the other coordinates.\"), mdx(\"h2\", null, \"The Solution\"), mdx(\"p\", null, \"It starts with the usual data read, plus a bit of processing to turn each line into an array of two numbers:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nlet input = fs\\n  .readFileSync(`./input/day6.txt`, 'utf8')\\n  .trim()\\n  .split('\\\\n')\\n  .map(line => line.split(', ').map(Number))\\n\")), mdx(\"p\", null, \"This goes a bit against my philosophy of always preferring objects over arrays to store data unless there's a good reason to choose arrays. In this case my reason was that arrays seemed just a little bit easier.\"), mdx(\"p\", null, \"Then gather all the x values and all the y values and find maxes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const xMax = Math.max(...input.map(([x, y]) => x))\\nconst yMax = Math.max(...input.map(([x, y]) => y))\\n\")), mdx(\"h2\", null, \"Clearly a Bad idea\"), mdx(\"p\", null, \"At first I thought I would have to iterate over the whole grid, measuring the distance from each point on the grid to the nearest point from the input. That was going to be a lot of calculation; the grid is about 350x350, meaning over a million points, and there are about 250 points in the input list. I didn't see an obvious solution for deciding which input was closest to a given grid point without calculating every distance.\"), mdx(\"h2\", null, \"So Many Questions\"), mdx(\"p\", null, \"Instead I decided to measure outward, starting at each input point and finding its neighboring points, then all the neighbors of those points, etc. I would sort of build concentric circles around each input point, and each loop through the code would increase the radius of the circles. How would I know when to stop looping? I had no idea. What would I do when the expanding circles around each input point started to overlap? Not sure. What did I know how to do? Well, given a point, I could find the four points adjacent to it, and check to find which of them were on the grid:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const findNeighbors = ([x, y]) => {\\n  let prospects = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]\\n  return prospects.filter(\\n    ([X, Y]) => X >= 0 && Y >= 0 && X <= xMax && Y <= xMax\\n  )\\n}\\n\")), mdx(\"h2\", null, \"On to Data Storage\"), mdx(\"p\", null, \"Once I found the nearest neighbors for an coordinate, I'd need to store them somewhere. An object didn't seem like the right answer, because there was no clear candidate for a key to associate with each value. The other option was an array.\"), mdx(\"h3\", null, \"A Confession\"), mdx(\"p\", null, \"I tried to solve the Advent of Code problems, and write up these explanations, as the problems came available, during December 2018. I got almost all of the problems done on the day they were released. I wrote up most of the explanations as soon as I had the solutions. Apparently for this problem, my explanation write up got as far as the end of the last paragraph. I haven't touched this write up since December 7, 2018. It is now May 5, 2019. The rest of this explanation is going to be an attempt to recreate my thoughts based on my code.\"), mdx(\"h2\", null, \"Back to Data Storage\"), mdx(\"p\", null, \"I want to store all of the coordinates that are nearest to each of the coordinates in the input list. The problem with using an object to store each neighbor by itself is figuring out the right key. Suppose I wanted all the neighbors for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[1, 1]\"), \", which would include the points \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0, 1]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[2, 1]\"), \". I couldn't do something like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{ \\\"1, 1\\\": [0, 1], \\\"1, 1\\\": [2, 1] }\\n\")), mdx(\"p\", null, \"because the keys in an object have to be unique. I suppose I could reverse the keys and values, but then all of the coordinates from the input list would be buried in the values and hard to get to without digging through thousands of keys. Another option would be to store everything in an object, but have each value be an array of the points closest to the coordinate represented by the key. Taking the above example, the data structure would look like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{ \\\"1, 1\\\": [ [0, 1], [2, 1] ] }\\n\")), mdx(\"p\", null, \"The key is a coordinate from the input list, the value is an array, and each element of that array is a point close to the coordinate key.\"), mdx(\"p\", null, \"That didn't seem quite right either. I was pretty sure I wanted to work with expanding concentric circles around each input coordinate. In order to build the next concentric circle, it would help to know where the last concentric circle was. To do that, I should store all of the points that made up each \\\"circle\\\" together in the data structure, without mixing all of the coordinates from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"every\"), \" \\\"circle\\\" together. I finally settled on something like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{\\n  \\\"key representing an input coordinate\\\": [\\n    [ /*all the points 1 space out from the coordinate */ ],\\n    [ /*all the points 2 spaces out from the coordinate */ ],\\n    ...\\n  ]\\n}\\n\")), mdx(\"h2\", null, \"Starting Solution\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","slug":"/2018-advent-of-code-day-six/","timeToRead":2,"wordCount":442,"frontMatter":{"date":"2019-05-05","title":"Again with the Geometry","tags":["education","javascript","Advent of Code"]},"prev":{"id":"c46df0df-2d72-5d4d-bbcc-07440881ed2d","parent":{"name":"2018-advent-of-code-day-five"},"excerpt":"The Problem There is a ( really  long) string made up of a mix of uppercase and lowercase letters. The string is to be shortened by removing…","fields":{"slug":"/2018-advent-of-code-day-five/"},"timeToRead":2,"wordCount":{"words":508},"frontmatter":{"date":"2019-05-05","title":"That's React_ion_, not React","tags":["education","javascript","Advent of Code"]}},"next":{"id":"b7118581-8cfd-5918-8049-7800ffaeba3c","parent":{"name":"2018-advent-of-code-day-one"},"excerpt":"2018 Advent of Code, Day One Advent of Code  is a series of software puzzles released every year during Advent ^advent . There's a cute…","fields":{"slug":"/2018-advent-of-code-day-one/"},"timeToRead":4,"wordCount":{"words":1158},"frontmatter":{"date":"2019-05-04","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]}}}}