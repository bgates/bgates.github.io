{"data":{"mdx":{"id":"bad906f4-932d-5a95-9701-97aba53cdcd4","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/advent-of-code-day-1\",\n  \"slug\": \"/first-post\",\n  \"date\": \"2019-04-24\",\n  \"order\": 2,\n  \"title\": \"2018 Advent of Code, Day 1\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.adventofcode.com\"\n  }), \"Advent of Code\"), \" is a series of software puzzles released every year during Advent\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-advent\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-advent\",\n    \"className\": \"footnote-ref\"\n  }), \"advent\")), \". There's a cute Christmas-themed story that ties the puzzles together. Every day at midnight\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-midnight\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-midnight\",\n    \"className\": \"footnote-ref\"\n  }), \"midnight\")), \", a link to the day's first puzzle goes live on the Advent of Code site. When you solve that puzzle, you get a link to a second puzzle which builds on the first. The problems are great examples of the kinds of algorithmic challenges that can come up in large scale production code, but almost never happen in personal projects. That means they resemble the whiteboard job interview stuff that nobody I know likes. The critical difference is that Christmas is a much more enjoyable theme than My Career and Therefore Life Are At Stake Why Can't I Do This Damn You Whiteboard Damn You to Hell.\"), mdx(\"p\", null, \"I think the Advent of Code is especially well-suited for bootcamp grads who have been out for a while.\"), mdx(\"p\", null, \"The first problem of Day One amounts to reading a set of numerical frequency changes and calculating where the frequency ends up. Quoting from the site:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"For example, if the device displays frequency changes of\\n+1, -2, +3, +1, then starting from a frequency of zero,\\nthe following changes would occur:\\n\\n\\nCurrent frequency  0, change of +1; resulting frequency  1.\\nCurrent frequency  1, change of -2; resulting frequency -1.\\nCurrent frequency -1, change of +3; resulting frequency  2.\\nCurrent frequency  2, change of +1; resulting frequency  3.\\nIn this example, the resulting frequency is 3.\\n\\nHere are other example situations:\\n\\n+1, +1, +1 results in  3\\n+1, +1, -2 results in  0\\n-1, -2, -3 results in -6\\n\")), mdx(\"p\", null, \"The problem includes a link to a page that just has numbers, some positive and some negative, each on its own line, like the following Example Data\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"-19\\n+3\\n+7\\n-1\\n+21\\n\")), mdx(\"p\", null, \"OK, here's how I solved it:\"), mdx(\"p\", null, \"First I saved the file with the numbers as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"day1.txt\"), \". Then I opened a new file, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"day1.js\"), \", and wrote some Node code to read the data file:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst input = fs.readFileSync(`./input/day1.txt`, 'utf8').trim()\\n\")), mdx(\"p\", null, \"The first line lets me use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fs\"), \" Node module, which handles file operations synchronously (so I don't have to deal with asynchronous stuff like promises or async/await). The second line reads that file and holds it in a variable called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \", which is a string.\"), mdx(\"p\", null, \"The next step is to turn the one string into a bunch of numbers:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sequence = input.split('\\\\n').map(Number)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" is a string with a \\\"number\\\" on each line, so \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input.split(\\\"\\\\n\\\")\"), \" returns an array with the \\\"number\\\"s as elements. The quotes around \\\"number\\\" are there to emphasize that at this point, they're not actual numbers yet - they're still strings, like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" was. I now have to change the array of \\\"number\\\"s into an array of numbers. A job for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \"!\"), mdx(\"p\", null, \"Here's something kind of clever. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" takes a function as an argument, and that function is invoked with each element of the array being mapped. There are a few ways to write a function that does what I need, which is to take a string like \\\"7\\\" as an argument and return a number like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"7\"), \". All of them use the built-in function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \", which does exactly what I need:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"Number('+7') // returns 7\\n\")), mdx(\"p\", null, \"The most common way to write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \"'s argument is as an arrow function, like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"string => Number(string)\\n\")), mdx(\"p\", null, \"That's a function that takes a single argument, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \", and returns the value you get from invoking \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" with that argument, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number(string)\"), \". I could have generated the sequence of numbers from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" string with\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sequence = input.split('\\\\n').map(string => Number(string))\\n\")), mdx(\"p\", null, \"But there's a more compact way of writing the argument to map, which is a function that takes a single argument and returns the same return value as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"Number\\n\")), mdx(\"p\", null, \"That works because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"itself\"), \" \\\"a function that takes a single argument and returns the value you get from invoking \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \"\\\". And because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" works exactly the same as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string => Number(string)\"), \", I can get the sequence of numbers with\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sequence = input.split('\\\\n').map(Number)\\n\")), mdx(\"p\", null, \"After all that, I have an array of numbers in the variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sequence\"), \", and I eed to add them all together. That's a job for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sum = sequence.reduce((total, current) => total + current, 0)\\n\")), mdx(\"p\", null, \"And that's the answer to Part One.\"), mdx(\"p\", null, \"Part Two gets tougher.\"), mdx(\"p\", null, \"The goal of Part Two is to use the same list of changes from Part One and find the first frequency that repeats. It may be necessary to go through the list of changes more than once.\"), mdx(\"p\", null, \"Using the list of Example Data from before\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"-19\\n+3\\n+7\\n-1\\n+21\\n\")), mdx(\"p\", null, \"starting from 0, applying the frequency changes one at a time, gets the following frequencies:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"0 - 19 = -19\\n-19 + 3 = -16\\n-16 + 7 = -9\\n-9 - 1 = -10\\n-10 + 21 = 11\\n(repeat the list)\\n11 - 19 = -8\\n-8 + 3 = 5\\n5 + 7 = 12\\n12 - 1 = 11\\n\")), mdx(\"p\", null, \"For this list, 11 is the first frequency that occurs twice.\"), mdx(\"p\", null, \"Naturally, the list in the Advent of Code problem is a lot bigger - over 1000 numbers, structured in a way that means the list has to be looped over many times to get a single frequency to repeat. We'll have to write code for this one.\"), mdx(\"p\", null, \"The solution to this problem has to do the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"keep track of which frequencies have already occurred\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"detect when a frequency occurs twice\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"loop over the list an indefinite number of times, until a frequency repeats\")), mdx(\"p\", null, \"If you're like me, the first thing you think of to store a bunch of data is an array. To find whether an array includes a value, you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".includes()\"), \" method. For this problem, with the amount of data involved, that works! But it's not the best. Here's a solution, with some timing code added so we can see how long it takes.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// sequence is defined as above\\nconsole.time('arraySolution')\\nlet currentFrequency = 0\\nlet allFrequencies = []\\nlet sequenceIndex = 0\\nwhile (!allFrequencies.includes(currentFrequency)) {\\n  allFrequencies.push(currentFrequency)\\n  currentFrequency += sequence[sequenceIndex]\\n  sequenceIndex += 1\\n  if (sequenceIndex === sequence.length) {\\n    sequenceIndex = 0\\n  }\\n}\\nconsole.log(currentFrequency)\\nconsole.timeEnd('arraySolution')\\n\")), mdx(\"p\", null, \"The calls to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.time('arraySolution')\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.timeEnd('arraySolution')\"), \" provide benchmarking data, meaning at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeEnd\"), \" what gets printed to the console is the time elapsed since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.time\"), \". (The timer name argument is optional in this case; in more complicated code, multiple timers can be run at the same time by giving each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeEnd\"), \" pair its own name.)\"), mdx(\"p\", null, \"This solution is valid, but it's slow. On my 2014 MacBook Air, it takes about 14000ms. We can do better.\"), mdx(\"p\", null, \"Objects can be used to store data, too. Usually, objects have categorical keys and specific values, like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let computer = {\\n  manufacturer: 'Apple',\\n  operatingSystem: 'macOS Sierra',\\n}\\n\\nlet phone = {\\n  manufacturer: 'Motorola',\\n  operatingSystem: 'Android 8.1.0',\\n}\\n\")), mdx(\"p\", null, \"For this problem, there aren't any categories like \\\"manufacturer\\\" to associate with the frequencies we want to store. The solution is to use the frequencies themselves as the keys! Or at least the string versions of them - all keys in JavaScript objects are strings. The value associated with every key in the object can be simply \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \", because the only thing of interest about a key in this object is that it exists in the object.\"), mdx(\"p\", null, \"The frequencies derived from the example data above (which were -19, -16, -9, etc) could be stored in an object like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let frequencies = { '-19': true, '-16': true, '-9': true }\\n\")), mdx(\"p\", null, \"Once we have an object with frequencies used for keys, looking for a frequency means accessing the key in the object:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"frequencies[-16] // true; -16 is a frequency in the object\\nfrequencies[42] // undefined; 42 is not a frequency in the object\\n\")), mdx(\"p\", null, \"Accessing a key in an object like that is much faster than searching through an array with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".includes\"), \". Here is the object-focused solution:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"console.time('objectSolution')\\nlet currentFrequency = 0\\nlet allFrequencies = {}\\nlet sequenceIndex = 0\\nwhile (!allFrequencies[currentFrequency]) {\\n  allFrequencies[currentFrequency] = true\\n  currentFrequency += sequence[sequenceIndex]\\n  sequenceIndex += 1\\n  if (sequenceIndex === sequence.length) {\\n    sequenceIndex = 0\\n  }\\n}\\nconsole.log(currentFrequency)\\nconsole.timeEnd('objectSolution')\\n\")), mdx(\"p\", null, \"More than half of this code is identical to the array solution. The only changes are\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"initializing \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"allFrequencies\"), \" to an empty object instead of an empty array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"looking for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"currentFrequency\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"while\"), \" condition with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"!allFrequencies[currentFrequency]\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"!allFrequencies.includes(currentFrequency)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"adding to the data collection with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"allFrequencies[currentFrequency] = true\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"allFrequencies.push(currentFrequency)\"))), mdx(\"p\", null, \"Even so, using an object instead of an array reduces the algorithm's runtime from ~14000ms to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"~20ms\"), \".\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-advent\"\n  }), \"Traditionally, the period between the fourth Sunday before Christmas and Christmas itself; here, simply December 1-25.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-advent\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")), mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-midnight\"\n  }), \"Eastern Standard Time. Developers from all over the world compete to see who can solve these puzzles the fastest, and the only reliable way to measure that is to open the puzzles to the whole world at once.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-midnight\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"bad906f4-932d-5a95-9701-97aba53cdcd4","slug":"/advent-of-code-day-1","frontMatter":{"path":"/advent-of-code-day-1","title":"2018 Advent of Code, Day 1","tags":["education","javascript","Advent of Code"]},"prev":null,"next":{"id":"4c59a18d-07b7-5328-ba62-36051155f98d","parent":{"name":"2018-12-02-advent-of-code-day-2"},"code":{"scope":""},"frontmatter":{"path":"/advent-of-code-day-2","title":"2018 Advent of Code, Day 2","tags":["education","javascript","Advent of Code"]}}}}