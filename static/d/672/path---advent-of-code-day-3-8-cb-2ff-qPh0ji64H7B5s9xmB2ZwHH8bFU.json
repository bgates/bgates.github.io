{"data":{"mdx":{"id":"70e13885-5d94-59ec-8838-bfdc90bb00a4","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/advent-of-code-day-3\",\n  \"date\": \"2019-05-03\",\n  \"title\": \"2018 Advent of Code, Day 3\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Today's problem involves a lot of squares, and it would be easier if I could just see it, so I ended up making some drawings by the time I finished.\"), mdx(\"p\", null, \"The input data describes the squares. The descriptions look like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"#123 @ 3,2: 5x4\\n\")), mdx(\"p\", null, \"where the numbers represent id (123), bottom left corner (3 for the bottom, 2 for the left), width (5) and height (guess). There are a bunch of lines like that, and I'm supposed to figure out how much overlap there is among all of them.\"), mdx(\"p\", null, \"Data is provided in the usual file, and we begin extracting it in the usual way:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst input = fs\\n  .readFileSync(`./input/day3.txt`, 'utf8')\\n  .trim()\\n  .split('\\\\n')\\n\")), mdx(\"p\", null, \"That gets an array of strings, each with data about what the problem calls a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"claim\"), \" (and I call a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"rectangle\"), \", because I'm fancy). What I care about are the numbers in each string, and what they represent - the bottom, left, etc for each claim. I'd like to hold on to each number along with each label. For instance, for the example line I showed above, I would change it into\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// '123 @ 3, 2: 5x4'\\n{\\n  id: 123,\\n  left: 3,\\n  bottom: 2,\\n  width: 5,\\n  height: 4\\n}\\n\")), mdx(\"p\", null, \"-and store the data in an object. That way I can get the left edge or the bottom or whatever back out easily. Actually, as I look at the object, I'm not quite satisfied with it. The labels \\\"left\\\" and \\\"bottom\\\" don't really pair naturally with \\\"width\\\" and \\\"height\\\", \\\"right\\\" and \\\"top\\\" do. I could calculate those. If the left is 3, and the width is 5, then the right should be...7. (I thought it should have been 8, and it messed me up for an hour. See the footnote for what I figured out.)\"), mdx(\"p\", null, \"OK, I'm starting with an array of strings, and I want to transform each string into an object. That's a job for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \". I know what the \\\"shape\\\" of each object will be, so I have to figure out a callback function for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" that will turn one string into one object. The string has numbers in it, mixed in with other characters like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \", and I need to get the numbers out. That sounds like a job for a regular expression. I'll get the numbers out, put them in the object, Bob's your uncle.\"), mdx(\"p\", null, \"Here's the callback function I came up with:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const parseClaim = claimString => {\\n  const match = claimString\\n    .match(/#(\\\\d+) @ (\\\\d+),(\\\\d+): (\\\\d+)x(\\\\d+)/)\\n    .map(Number)\\n  return {\\n    id: match[1],\\n    left: match[2],\\n    bottom: match[3],\\n    right: match[4] + match[2] - 1,\\n    top: match[5] + match[3] - 1,\\n  }\\n}\\n\")), mdx(\"p\", null, \"That's a function that will take a string, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"claimString\"), \", and match it against a regular expression. The argument to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".match()\"), \" is a regular expression that includes all of the formatting characters like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" that I know \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"claimString\"), \" will have. The regular expression also has five separate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(\\\\d+)\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\d\"), \" means \\\"find a digit (any of 0 - 9).\\\" Adding a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"+\"), \" to make \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\d+\"), \" means \\\"find one or more digits, in a row\\\". Adding parentheses to make \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(\\\\d+)\"), \" means \\\"hold on to those digits, I might need them later\\\". If I used that call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".match()\"), \" on my trusty example line, the return value would have the digits \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"123\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"3\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"4\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5\"), \" in an array\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-1\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }), \"1\")), \". Since the digits are coming out of a regular expression match on a string, they're strings too. That's why I mapped the array through \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \", to get an array of numbers.\"), mdx(\"p\", null, \"I want to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseClaim\"), \" on every string in my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" array, so I give it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" as the callback function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const parsedData = input.map(parseClaim)\\n\")), mdx(\"p\", null, \"I'm supposed to calculate the number of square inches that are part of multiple claims. The first approach I thought of was to iterate over the entire grid, and for each point, try to find how many claims it was part of. The drawback to that is that some points are not in any of the claims, and it would be a waste of time to look at them. Instead, I decided to iterate over each of the claims, and compare it to each of the others:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let i = 0; i < parsedData.length; i += 1) {\\n  for (let j = i + 1; j < parsedData.length; j += 1) {\\n    const [claim1, claim2] = [parsedData[i], parsedData[j]]\\n    // find the overlap between claim1 and claim2\\n  }\\n}\\n\")), mdx(\"p\", null, \"There are a few similarities between what I'm doing here and what I did for the second part of yesterday's problem - nested \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loops, starting the inner index with the value after the value of the outer index, and getting the two values to compare based on each index. That's a nice little reminder of how you start to see familiar patterns if you work at this long enough.\"), mdx(\"p\", null, \"Next I needed a function to find the overlap between two claims. Then again, many claims will have no overlap; it would be nice to have a quick way to make sure the claims overlap at all before looking at them in more detail:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const [claim1, claim2] = [parsedData[i], parsedData[j]]\\nif (hasOverlap(claim1, claim2)) {\\n  // find the overlap between claim1 and claim2\\n}\\n\")), mdx(\"p\", null, \"I can tell \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \" is going to return a boolean value, both because I'm using it in a conditional and because it's expressing the answer to a yes/no kind of question, do two things overlap or not. Writing a function for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \" seems hard, so I'm not going to do it. Instead, I'll look at a related problem: how to find if two claims \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"don't\"), \" overlap. I'll write a function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noOverlap\"), \". Any time \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noOverlap\"), \" is true, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \" would have to be false. Any time \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noOverlap\"), \" is false, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \" would be true. So I could define one in terms of the other:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const hasOverlap(claim1, claim2) => !noOverlap(claim1, claim2)\\n\")), mdx(\"p\", null, \"That means I'll get \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \" - as soon as I figure out \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noOverlap\"), \". This is where the drawing I mentioned at the start of the post comes in. I need to look at a couple of rectangles that don't overlap, and figure out a way to express their \\\"non-overlappiness\\\" using the information I have about each one. Here's one situation in which claim A does not overlap claim B, with numbers along the top of the grid to denote inches from the edge:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"01234567\\n........\\n.AA..BB.\\n.AA..BB.\\n........\\n\")), mdx(\"p\", null, \"I had to express how I knew those claims were non-overlapping using the information I have about each claim, which is stored in an object with the properties \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"left\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"top\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"right\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bottom\"), \". Imagine moving or expanding either of those rectangles until they overlapped. I'd have to move the right edge of A further right, and/or the left edge of B further left. It wouldn't matter if I move either of them up or down. They don't overlap because A is not far enough to the right, or B is not far enough left, depending on how you want to look at it. In terms of the numerical properties the claims have, I could say that they don't overlap because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"right\"), \" edge of A (which is 2) is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"less than\"), \" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"left\"), \" edge of B (which is 5).\"), mdx(\"p\", null, \"Likewise, if I have claim A below claim B:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"4.......\\n3..BB...\\n2..BB...\\n1.......\\n0..AA...\\n\")), mdx(\"p\", null, \"I can say that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"top\"), \" edge of A is less than the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bottom\"), \" edge of B.\\nIf had A and B switch places, it would work the same - then the top edge of B would be less than the bottom edge of A. Now it wouldn't matter if I moved either claim to the left or right - they don't overlap top-to-bottom, so they can't overlap at all.\"), mdx(\"p\", null, \"I can use those kinds of numerical comparisons to write my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noOverlap\"), \" function, which I know will take two claim objects as parameters and return a boolean:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const noOverlap = (claim1, claim2) =>\\n  claim1.right < claim2.left ||\\n  claim2.right < claim1.left ||\\n  claim1.top < claim2.bottom ||\\n  claim2.top < claim1.bottom\\n\")), mdx(\"h2\", null, \"Let's Put All the Code Together\"), mdx(\"p\", null, \"Here's the code I have so far, which reads data from a file into a string, converts the data from a string into an array of objects, then has a nested loop over that array which checks whether each pair of objects has any overlap:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst input = fs\\n  .readFileSync(`./input/day3.txt`, 'utf8')\\n  .trim()\\n  .split('\\\\n')\\n\\nconst parseClaim = claimString => {\\n  const match = claimString\\n    .match(/#(\\\\d+) @ (\\\\d+),(\\\\d+): (\\\\d+)x(\\\\d+)/)\\n    .map(Number)\\n  return {\\n    id: match[1],\\n    left: match[2],\\n    bottom: match[3],\\n    right: match[4] + match[2] - 1,\\n    top: match[5] + match[3] - 1,\\n  }\\n}\\nconst parsedData = input.map(parseClaim)\\n\\nconst noOverlap = (claim1, claim2) =>\\n  claim1.right < claim2.left ||\\n  claim2.right < claim1.left ||\\n  claim1.top < claim2.bottom ||\\n  claim2.top < claim1.bottom\\nconst hasOverlap = (claim1, claim2) => !noOverlap(claim1, claim2)\\n\\nfor (let i = 0; i < parsedData.length; i += 1) {\\n  for (let j = i + 1; j < parsedData.length; j += 1) {\\n    const [claim1, claim2] = [parsedData[i], parsedData[j]]\\n    if (hasOverlap(claim1, claim2)) {\\n      // findAllOverlap(claim1, claim2)\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"I have a comment in there to remind myself that it's not enough to get a boolean answer to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \". If there is any overlap between two claim objects, I have to calculate how much. To find the overlap between two claims, I can take one claim and iterate over it inch by inch, from the left edge to the right and from bottom to top, and check each square inch to see if it was inside the other claim. The fact that I'm measuring overlap between two claim objects makes me think those will be the parameters to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \" function. When I find some overlap, I'll have to keep track of it somehow. The requirement of calculating an amount of something made me think the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"findAllOverlap\"), \" function would return a number. Then I realized I need to keep track of all the overlap,for all pairs of claims, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" be careful not to double-count any square inch that's part of more than one pair. I don't know what the return value will be yet, but I can write the iterations I have to go through in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"findAllOverlap\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const findAllOverlap = (claim1, claim2) => {\\n  for (let x = claim1.left; x <= claim1.right; x += 1) {\\n    for (let y = claim1.bottom; y <= claim1.top; y += 1) {\\n      if (inside(claim2, x, y)) {\\n        // keep track of overlap at point (x, y)\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"I snuck in a call to a function I haven't defined yet: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inside\"), \", which takes a claim and a pair of (x, y) coordinates to see if the coordinates are inside the claim, returning true if they are and false if they're not. What does it mean, in terms of the data we have, to say that x and y mark a spot inside a claim? Well, I can make another drawing to illustrate. This time I'll show one rectangular claim A, and highlight one point that overlaps A with a \", \"*\", \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \" 01234\\n4.....\\n3.A*..\\n2.AA..\\n1.....\\n0.....\\n\")), mdx(\"p\", null, \"Clearly, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" overlaps with A, and it still would even if I moved the \"), \" down a bit and/or left a bit. It would not overlap if I moved it up and/or to the right. If I wrote the claims object for A, it would look like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{ top: 3, bottom: 2, left: 1, right: 2 }\\n\")), mdx(\"p\", null, \"The (x, y) coordinates for the overlapping point with the \", \"*\", \" are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(2, 3)\"), \". Comparing those sets of numbers while looking at the picture, I can tell that there's overlap if the x is greater than or equal to the claim's left edge - but less than or equal to the claim's right edge. Same for the top and bottom vs y. Translating that logic into code produces:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const inside = (claim, x, y) =>\\n  x >= claim.left && x <= claim.right && y >= claim.bottom && y <= claim.top\\n\")), mdx(\"p\", null, \"All that is left for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"findAllOverlap\"), \" is to keep track of the overlapping points. The need to store data takes me back into the array vs object debate. At the end, I'll have to calculate how many points of overlap there are, which is a strong argument for using an array. On the other hand, if I push each overlapping point into an array, I'd have to take care not to duplicate any points (which could happen if a point is contained within three or more claims). I decided to go with an object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let claimConflicts = {}\\nconst findAllOverlap = (claim1, claim2) => {\\n  for (let x = claim1.left; x <= claim1.right; x += 1) {\\n    for (let y = claim1.bottom; y <= claim1.top; y += 1) {\\n      if (inside(claim2, x, y)) {\\n        claimConflicts[`${x},${y}`] = true\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"I defined the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"claimConflicts\"), \" object \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"outside\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"findAllOverlap\"), \", so that every time I use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"findAllOverlap\"), \" I will be reusing the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"claimConflicts\"), \". That way it will end up with all of the overlap for every pair of claims.\"), mdx(\"p\", null, \"Note the transformation of the x,y pair into a single string with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${x},${y}\"), \". I did that because the keys of my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"claimConflicts\"), \" object (or any other JavaScript object) have to be strings. Using x and y to make the key saves me from worrying about hitting the same x, y point twice, because I'd just end up reassigning the same key-value pair.\"), mdx(\"p\", null, \"Come to think of it, if I already have an x, y point stored as a key in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"claimConflicts\"), \", there's no point in making the call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inside\"), \". I could make the code more efficient (how much I'm not sure) by checking \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"claimConflicts\"), \" in the last conditional:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let claimConflicts = {}\\nconst findAllOverlap = (claim1, claim2) => {\\n  for (let x = claim1.left; x <= claim1.right; x += 1) {\\n    for (let y = claim1.bottom; y <= claim1.top; y += 1) {\\n      if (!claimConflicts[`${x},${y}`] && inside(claim2, x, y)) {\\n        claimConflicts[`${x},${y}`] = true\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"That gives the final answer to part one:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst input = fs\\n  .readFileSync(`./input/day3.txt`, 'utf8')\\n  .trim()\\n  .split('\\\\n')\\n\\nconst parseClaim = claimString => {\\n  const match = claimString\\n    .match(/#(\\\\d+) @ (\\\\d+),(\\\\d+): (\\\\d+)x(\\\\d+)/)\\n    .map(Number)\\n  return {\\n    id: match[1],\\n    left: match[2],\\n    bottom: match[3],\\n    right: match[4] + match[2] - 1,\\n    top: match[5] + match[3] - 1,\\n  }\\n}\\nconst parsedData = input.map(parseClaim)\\n\\nconst noOverlap = (claim1, claim2) =>\\n  claim1.right < claim2.left ||\\n  claim2.right < claim1.left ||\\n  claim1.top < claim2.bottom ||\\n  claim2.top < claim1.bottom\\nconst hasOverlap = (claim1, claim2) => !noOverlap(claim1, claim2)\\n\\nconst inside = (claim, x, y) =>\\n  claim.left <= x && claim.right >= x && claim.bottom <= y && claim.top >= y\\n\\nlet claimConflicts = {}\\nconst findAllOverlap = (claim1, claim2) => {\\n  for (let x = claim1.left; x <= claim1.right; x += 1) {\\n    for (let y = claim1.bottom; y <= claim1.top; y += 1) {\\n      if (!claimConflicts[`${x},${y}`]) {\\n        if (inside(claim2, x, y)) {\\n          claimConflicts[`${x},${y}`] = true\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nfor (let i = 0; i < parsedData.length; i += 1) {\\n  for (let j = i + 1; j < parsedData.length; j += 1) {\\n    const [claim1, claim2] = [parsedData[i], parsedData[j]]\\n    if (hasOverlap(claim1, claim2)) {\\n      findAllOverlap(claim1, claim2)\\n    }\\n  }\\n}\\nconsole.log(Object.keys(claimConflicts).length)\\n\")), mdx(\"p\", null, \"Part two asks us to find the one claim that has no overlap with any others. To solve that problem, I'll be able to reuse most of the code I alrady have. If anything, part two is simpler, because for any pair of claims, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \" is what we care about. To find the one claim with no overlap, we'll find all the other claims that do have overlap. Then the claim we want will be the only one missing from the list of overlappers.\"), mdx(\"p\", null, \"As I said, we have code to find if two claims \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasOverlap\"), \". Similar to storing the x,y values of each overlapping point in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"claimConflicts\"), \" before, we can store something about each claim that has overlap in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overlappingClaims\"), \" object. Since all of the claims are in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parsedData\"), \" array, and we're iterating over that array in a couple of loops, it will be convenient to use the array index of each claim as a key in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overlappingClaims\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let overlappingClaims = {}\\nfor (let i = 0; i < parsedData.length; i += 1) {\\n  for (let j = i + 1; j < parsedData.length; j += 1) {\\n    const [claim1, claim2] = [parsedData[i], parsedData[j]]\\n    if (hasOverlap(claim1, claim2)) {\\n      overlappingClaims[i] = true\\n      overlappingClaims[j] = true\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"By the end of it, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overlappingClaims\"), \" will be an object that has a key for all but one of the index values of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parsedData\"), \" array's elements. Now we can find which index value is missing from that collection of keys, and that will be the index value of the claim that has no overlap. As it happens, there is an array method called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"find\"), \", and it can be invoked with a callback function that takes two parameters, an array element and that element's index. In this case, the array element itself doesn't matter in the callback function, so I'll indicate that by using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_\"), \" for the first parameter. (That doesn't mean anything special to JavaScript, but other developers can take it as a sign that I had to put something in for a parameter but I'm never going to use it.) Rather than finding based on the array element, this callback function will depend on the index value. We want to find the index value that is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" a key in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overlappingClaims\"), \" object:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const remainingClaim = parsedData.find((_, i) => !overlappingClaims[i])\\nconsole.log(remainingClaim)\\n\")), mdx(\"p\", null, \"For the sake of completeness, I should say that JavaScript is cheating a bit behind the scenes for us. I mentioned earlier that every key in a JavaScript object is a string. But in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loops as well as in the callback function for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"find\"), \", I used array index values as object keys - and those are numbers! What the?!?! It turns out JavaScript sees that kind of shenanigans coming a mile off, and it turns anything that gets used as a key into a string for you. So what you thought was \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overlappingClaims[0]\"), \" was actually \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overlappingClaimns[\\\"0\\\"]\"), \" the whole time.\"), mdx(\"p\", null, \"*\", \"I missed the -1 for about an hour, until I finished the algorithm and got the wrong answer a few times. Then I went back to the sample data to see if I could parse it correctly, using the problem statement's pictures to guide me. From the problem statement:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"A claim like #123 @ 3,2: 5x4 means that claim ID 123 specifies a rectangle 3 inches from the left edge, 2 inches from the top edge, 5 inches wide, and 4 inches tall. Visually, it claims the square inches of fabric represented by # (and ignores the square inches of fabric represented by .) in the diagram below:\\n\\n...........\\n...........\\n...#####...\\n...#####...\\n...#####...\\n...#####...\\n...........\\n...........\\n...........\\n\")), mdx(\"p\", null, \"As you can see, if the left side of the claim is three inches from the edge, then it makes sense to think of the dots as numbers starting from 0:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"...........\\n012345678..\\n...#####...\\n\")), mdx(\"p\", null, \"So if the left edge is at index 3, the right edge is at index 7, which is 3 + 5 - 1.\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-1\"\n  }), \"not exactly an array\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"70e13885-5d94-59ec-8838-bfdc90bb00a4","slug":"/advent-of-code-day-3","timeToRead":9,"wordCount":{"words":2338},"frontMatter":{"path":"/advent-of-code-day-3","date":"2019-05-03","title":"2018 Advent of Code, Day 3","tags":["education","javascript","Advent of Code"]},"prev":{"id":"81397385-bc99-58b0-8260-7307c9d79350","parent":{"name":"2018-12-04-advent-of-code-day-4"},"excerpt":"Day Four has us figuring out when to sneak by a sleeping guard, based on a set of notes about when each guard starts a shift, falls asleep…","timeToRead":3,"wordCount":{"words":760},"frontmatter":{"path":"/advent-of-code-day-4","date":"2019-05-03","title":"2018 Advent of Code, Day 4","tags":["education","javascript","Advent of Code"]}},"next":{"id":"23a17621-c678-590b-adf1-51ffa50346a6","parent":{"name":"2018-12-02-advent-of-code-day-2-part-2"},"excerpt":"The problem is to find two ids that are identical except for one letter, and then print out the letters those two ids have in common. I…","timeToRead":2,"wordCount":{"words":554},"frontmatter":{"path":"/advent-of-code-day-2-part-2","date":"2019-05-02","title":"2018 Advent of Code, Day 2, Part 2","tags":["education","javascript","Advent of Code"]}}}}