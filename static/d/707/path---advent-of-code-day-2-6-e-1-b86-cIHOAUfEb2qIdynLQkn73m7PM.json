{"data":{"mdx":{"id":"4c59a18d-07b7-5328-ba62-36051155f98d","code":{"body":"function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar layoutProps = {};\n\nvar MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    _classCallCheck(this, MDXContent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  _createClass(MDXContent, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n      return React.createElement(MDXTag, {\n        name: \"wrapper\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Day Two focuses on finding patterns in strings.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"For the first puzzle, we're asked to take a set of strings of letters referred to as \\\"ids\\\" and identify ids that contain duplicate letters. More specifically, count \"), React.createElement(MDXTag, {\n        name: \"ul\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"li\",\n        components: components,\n        parentName: \"ul\"\n      }, \"how many ids have \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"li\"\n      }, \"at least one letter that appears exactly twice\"), \", and\"), React.createElement(MDXTag, {\n        name: \"li\",\n        components: components,\n        parentName: \"ul\"\n      }, \"how many ids have \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"li\"\n      }, \"at least one letter that appears exactly three times\"), \".\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"For example,\"), React.createElement(MDXTag, {\n        name: \"ul\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"li\",\n        components: components,\n        parentName: \"ul\"\n      }, React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"li\"\n      }, \"abcdef\"), \" has no repeats. (I love \", React.createElement(\"a\", {\n        href: \"https://www.youtube.com/watch?v=emvySA1-3t8\"\n      }, \"explanations that start at that level\"), \".)\"), React.createElement(MDXTag, {\n        name: \"li\",\n        components: components,\n        parentName: \"ul\"\n      }, React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"li\"\n      }, \"abcabc\"), \" has letters that appear exactly twice. It doesn't matter how many letters appear exactly twice, just that at least one does.\"), React.createElement(MDXTag, {\n        name: \"li\",\n        components: components,\n        parentName: \"ul\"\n      }, React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"li\"\n      }, \"abcccf\"), \" has a letter that appears exactly three times - only one, but that's enough to count.\"), React.createElement(MDXTag, {\n        name: \"li\",\n        components: components,\n        parentName: \"ul\"\n      }, React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"li\"\n      }, \"aabbbc\"), \" has a letter that appears twice \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"li\"\n      }, \"and\"), \" a letter that appears three times, so this string counts for both categories.\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"If that was the whole set of ids, the final count would be two \\\"appears exactly twice\\\"s and two \\\"appears exactly three times\\\"s, and we wouldn't need software to deal with it. Fortunately, there are 250 ids, so I can get a blog post out of this.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Since the input data was once again made available as a text file, I was able to reuse some code from yesterday:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const fs = require('fs')\\nconst input = fs.readFileSync(`./input/day2.txt`, 'utf8').trim()\\nconst ids = input.split(\\\"\\\\n\\\")\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"That gets me to a good place on the input side - \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"ids\"), \" is an array of strings, and I know there are lots of things I can do with a data structure like that. \"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Next I'll take a minute to think about what I want to end up with. A few paragraphs ago I wrote about keeping count for strings with letters that appeared twice, and for strings with letters that appeared three times. That's two independent pieces of data, so I'll need some kind of container. The most fundamental in JavaScript are objects and arrays. Either of those would work here - there will only ever be two pieces of information, so the speed of access that was a concern yesterday doesn't matter in this problem. Even so, if there's not a good reason to choose an array, I prefer to use an object, because objects let me label the data I'm storing. That's the reasoning that led me to this data structure:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"let counts = {\\n  countOfIdsWithLetterAppearingTwice: 0, \\n  countOfIdsWithLetterAppearingThreeTimes: 0\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"I'm not super happy with the keys in that object; the length makes them a bit tough to read. On the bright side, I nailed the values - the initial counts are zero. Go, me.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"OK, now I know where I'm starting (\", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"ids\"), \", the array of strings) and where I want to end up (\", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"counts\"), \", an object), so I just need to put in the middle bits. I can get from an array to an object with \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".reduce()\"), \"; that method showed up yesterday, as a way to add together all the numbers in an array called \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"sequence\"), \": \"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const sum = sequence.reduce((total, current) => total + current, 0);\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"The way \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".reduce()\"), \" works is, it takes two arguments, a callback function and an initial value. For \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"sum\"), \", the initial value is 0, and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"(total, current) => total + current\"), \" is the callback function. As you can see, the callback function also takes two arguments\", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \", which represent an accumulator (something that keeps track of data) and an element from the array. (\"), \" The callback for \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".reduce\"), \" can take between one and four arguments, but I'm giving it two here.) Every element in the array takes a turn being \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"current\"), \". The callback function does whatever it has to do to produce a return value (for \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"sum\"), \" that just means adding \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"total\"), \" and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"current\"), \"), and that return value becomes the new \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"total\"), \". If \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"total\"), \" is always computed with the \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"previous\"), \" element in the array, there's no way to compute it for the \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"first\"), \" element in the array, and that's why there's an initial value - it's the initial value of \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"total\"), \".\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"To sum up (see what I did there?), if \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"sequence\"), \" is the array \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"[4, 5, 6]\"), \", \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"sum\"), \" would be calculated like this:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {}\n      }, \"// initial value        | 1st element in array | next total\\n        0               +       4                   = 4\\n// total from above     | 2nd element in array | next total\\n        4               +       5                   = 9\\n// total from above     | 3rd element in array | next total\\n        9               +       6                   = 15\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"There are a few differences between how \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".reduce()\"), \" was used for \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"sum\"), \" and how I need to use \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".reduce()\"), \" for this problem. For one thing, I need to keep track of two numbers, not just one, so the initial value will have to be different. For another, I'm not just adding two numbers together to get the return value from the callback function - I'm keeping track of two numbers and I might not be changing the numbers for every element in the array. I only want to count the ids with repeating letters, so I'll need some kind of conditional logic.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"I already have my initial value - it's the \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"counts\"), \" object. The bigger problem is to figure out what to do with that object in the callback function.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"One thing that could affect \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"counts\"), \" is if a string has any letters that appear twice. I have some intuition that I want to write a function to check that. That's because I'll also have to check if a string has any letters that appear three times, and those tasks sound so similar, I bet I'll be able to reuse some code between them.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"I'm not worried about how exactly this new function will fit in the callback function for \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".reduce()\"), \". It's enough to know that I need to check a string for repeated letters. That sounds like the new function will take one argument (the string) and return a boolean (because the question \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"are there letters that appear twice?\"), \" is answered either true or false).\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Since I need to check every letter in the string for how many times it appears, I don't think there's an ideal way to do that if I confine myself to string methods. If I need to do something with every member of a collection (like every letter in a string), the most convenient thing is to represent that collection as an array. Since I have a string, I can make an array out of it:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const letters = id.split('')\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Now I have an array of \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"letters\"), \", and I want to find whether any letter in that array appears twice. The Big Three methods for manipulating an array are \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".map()\"), \", \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".filter()\"), \", and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".reduce()\"), \", so I'll start by thinking about how they could help. \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".map()\"), \" returns an array that's the same length as the array I start with, which doesn't seem useful to help count repeating elements. \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".filter()\"), \" would return a new array with certain elements filtered out. Hey, if I filtered a letter out, and the new array is two elements shorter than the original array, then the letter must have appeared twice in the original array! \"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const appearTwice = letters.filter(letter => letter !== ...)\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Wait a minute. Which letter do I filter? I said earlier that I have to check all of them, to see if any of them appear twice. For that, I can use \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".some()\"), \":\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const appearTwice = letters.some(\\n  letterToFilter => (\\n    letters.filter(\\n      letter => letter !== letterToFilter\\n    ).length === letters.length - 2\\n  )\\n)\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"With \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".some()\"), \", I can go through \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"letters\"), \" one at a time. Each letter becomes \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"letterToFilter\"), \", and I use that in \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".filter()\"), \" to see whether filtering out \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"letterToFilter\"), \" leaves me with an array that's two letters shorter than what I started with. If it ever does, then \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"appearTwice\"), \" is true.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Checking if a letter appears three times is almost exactly the same:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const appearThreeTimes = letters.some(\\n  letterToFilter => (\\n    letters.filter(\\n      letter => letter !== letterToFilter\\n    ).length === letters.length - 3\\n  )\\n)\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Let's see how to use those in the callback for \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"reduce\"), \":\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const result = ids.reduce((total, id) => {\\n  const letters = id.split('')\\n  const appearTwice = letters.some(\\n    letterToFilter => (\\n      letters.filter(\\n        letter => letter !== letterToFilter\\n      ).length === letters.length - 2\\n    )\\n  )\\n  if (appearTwice) {\\n    // increase the count of ids with repeat letters, stored in `total`\\n  }\\n  const appearThreeTimes = letters.some(\\n    letterToFilter => (\\n      letters.filter(\\n        letter => letter !== letterToFilter\\n      ).length === letters.length - 3\\n    )\\n  )\\n  if (appearThreeTimes) {\\n    // increase the count of ids with letters that appear 3x, stored in `total`\\n  }\\n  return // an object to use for the next `total`\\n}, counts)\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"I'd like to reduce the duplication between \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"appearTwice\"), \" and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"appearThreeTimes\"), \", but first I'll complete the algorithm so I can make sure it runs properly. I have two comments where I need to increase the count of each kind of string I'm counting. I'm keeping track of those counts in the object \"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"let counts = {\\n  countOfIdsWithLetterAppearingTwice: 0, \\n  countOfIdsWithLetterAppearingThreeTimes: 0\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Since I'm using that as the initial value, it gets inside the callback function under the name \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"total\"), \". I can get each count out of the object with destructuring:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const result = ids.reduce((total, id) => {\\n  let { \\n    countOfIdsWithLetterAppearingTwice,\\n    countOfIdsWithLetterAppearingThreeTimes \\n  } = total\\n...\\n\\nThat provides me with two variables, `countOfIdsWithLetterAppearingTwice` and `countOfIdsWithLetterAppearingThreeTimes`. Then I can change those varibales in the conditionals:\\n\\n```javascript\\n  if (appearTwice) {\\n    countOfIdsWithLetterAppearingTwice += 1\\n  }\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"and use the varibles to make an object for the callback's return value:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"  return { \\n    countOfIdsWithLetterAppearingTwice, \\n    countOfIdsWithLetterAppearingThreeTimes\\n  }\\n\")), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const result = ids.reduce((total, id) => {\\n  let { \\n    countOfIdsWithLetterAppearingTwice,\\n    countOfIdsWithLetterAppearingThreeTimes \\n  } = total\\n  const letters = id.split('')\\n  const appearTwice = letters.some(\\n    letterToFilter => (\\n      letters.filter(\\n        letter => letter !== letterToFilter\\n      ).length === letters.length - 2\\n    )\\n  )\\n  if (appearTwice) {\\n    countOfIdsWithLetterAppearingTwice += 1\\n  }\\n  const appearThreeTimes = letters.some(\\n    letterToFilter => (\\n      letters.filter(\\n        letter => letter !== letterToFilter\\n      ).length === letters.length - 3\\n    )\\n  )\\n  if (appearThreeTimes) {\\n    countOfIdsWithLetterAppearingThreeTimes += 1\\n  }\\n  return { \\n    countOfIdsWithLetterAppearingTwice, \\n    countOfIdsWithLetterAppearingThreeTimes\\n  }\\n}, counts)\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"That works! Now I can tidy up a bit. There's a lot of duplication between \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"appearTwoTimes\"), \" and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"appearThreeTimes\"), \"; they're identical except for the number. I can pull that out into a function:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"  const appearNTimes = n => letters.some(\\n    letterToFilter => (\\n      letters.filter(\\n        letter => letter !== letterToFilter\\n      ).length === letters.length - n\\n    )\\n  )\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"That's a function that takes a single argument, \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"n\"), \", and returns all of the code that \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"appearTwoTimes\"), \" and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"appearThreeTimes\"), \" had in common. I can use the function to create those expressions:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"  const appearTwoTimes = appearNTimes(2)\\n  const appearThreeTimes = appearNTimes(3)\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"That slims things down:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"const result = ids.reduce((total, id) => {\\n  let { \\n    countOfIdsWithLetterAppearingTwice,\\n    countOfIdsWithLetterAppearingThreeTimes \\n  } = total\\n  const letters = id.split('')\\n  const appearNTimes = n => letters.some(\\n    letterToFilter => (\\n      letters.filter(\\n        letter => letter !== letterToFilter\\n      ).length === letters.length - n\\n    )\\n  )\\n  const appearTwice = appearNTimes(2)\\n  if (appearTwice) {\\n    countOfIdsWithLetterAppearingTwice += 1\\n  }\\n  const appearThreeTimes = appearNTimes(3)\\n  if (appearThreeTimes) {\\n    countOfIdsWithLetterAppearingThreeTimes += 1\\n  }\\n  return { \\n    countOfIdsWithLetterAppearingTwice, \\n    countOfIdsWithLetterAppearingThreeTimes\\n  }\\n}, initial)\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"This could be refactored some more, but I tend to obsess over that kind of thing, and I haven't started on the day's second puzzle. The second puzzle is shorter to describe, both for the problem and the solution. The problem is to find two ids that are identical except for one letter, and then print out the letters those two ids have in common. On to the solution.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Because I need to compare pairs of ids, I need to have two nested iterations, one inside the other (a \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"for\"), \" loop inside another \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"for\"), \" loop or a \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".forEach()\"), \" inside another \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".forEach()\"), \"). I don't want to compare \", React.createElement(MDXTag, {\n        name: \"em\",\n        components: components,\n        parentName: \"p\"\n      }, \"every\"), \" pair, though; when I find the two ids I want, I can stop. That's easier to do from inside a \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"for\"), \" loop than from inside a call to \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \".forEach()\"), \". I also don't want to compare any pair twice; once I compare the first to the second, I don't need to compare the second to the first. I have to make sure the second, inner \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"for\"), \" loop doesn't look at any elements that have already been looked at in the outer \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"for\"), \" loop. To do that, I can have the inner loop's index start at the next number after whatever the outer loop's index's value is:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (let innerIndex = outerIndex + 1; innerIndex < ids.length; innerIndex += 1) {\\n    // compare one id to another\\n  }\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"The point of having those indexes is to identify two id values I want to compare:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (let innerIndex = outerIndex + 1; innerIndex < ids.length; innerIndex += 1) {\\n    const [ first, second ] = [ ids[outerIndex], ids[innerIndex] ]\\n    // compare first to second\\n  }\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Now I want to compare the letters in \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"first\"), \" and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"second\"), \". That suggests more iteration. Since I want to compare the letters at the same position in both ids, I don't need more nesting; just one more \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"for\"), \" loop will do:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (let innerIndex = outerIndex + 1; innerIndex < ids.length; innerIndex += 1) {\\n    const [ first, second ] = [ ids[outerIndex], ids[innerIndex] ]\\n      for (let sharedIndex = 0; sharedIndex < first.length; sharedIndex += 1) {\\n      // compare a letter in first to the letter at the same index in second\\n      }\\n  }\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"I'm interested in finding the two id values that are different at only one position. That means (a) I need to keep track of how many positions are different, and (b) once a pair is different at two positions, I can go on to the next pair. I can take care of (b) by adding to the innermost \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"for\"), \" loop's condition:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (let innerIndex = outerIndex + 1; innerIndex < ids.length; innerIndex += 1) {\\n    const [ first, second ] = [ ids[outerIndex], ids[innerIndex] ]\\n    let differenceCount = 0\\n      for (let sharedIndex = 0; sharedIndex < first.length && differenceCount < 2; sharedIndex += 1) {\\n        if (first[sharedIndex] !== second[sharedIndex]) {\\n          differenceCount += 1\\n        }\\n      }\\n  }\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"OK, we're comparing each pair of ids in the \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"ids\"), \" array, counting how many letters are different in each pair, and bailing out of a comparison if the pair is different in more than one position. What if we make it all the way to the end of one pair of strings and they're different in only one position? We should break out of the loop. A \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"break\"), \" statement by itself isn't enough, because that will only break out of the inner loop. \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"break\"), \" can be given the label of the block to break out of. That means we'll need to add a label to the outer block:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"outerLoop: for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (let innerIndex = outerIndex + 1; innerIndex < ids.length; innerIndex += 1) {\\n    const [ first, second ] = [ ids[outerIndex], ids[innerIndex] ]\\n    let differenceCount = 0\\n    for (let sharedIndex = 0; sharedIndex < first.length && differenceCount < 2; sharedIndex += 1) {\\n      if (first[sharedIndex] !== second[sharedIndex]) {\\n        differenceCount += 1\\n      }\\n    }\\n    if (differenceCount === 1) {\\n      console.log('found them!', first, second)\\n      break outerLoop\\n    }\\n  }\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Getting close! In a pinch, you could look closely at that console output and type out one of the ids without the letter that's different between the two. That's actually how I submitted my solution to Advent of Code. To be thorough, here are the last steps to get the whole problem solved by software. We'll need to identify the position at which the two ids are different, then log out one of the ids with that position removed:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-javascript\"\n        }\n      }, \"    let differenceCount = 0\\n    let position\\n    for (let sharedIndex = 0; sharedIndex < first.length && differenceCount < 2; sharedIndex += 1) {\\n      if (first[sharedIndex] !== second[sharedIndex]) {\\n        differenceCount += 1\\n        position = sharedIndex\\n      }\\n    }\\n    if (differenceCount === 1) {\\n      console.log(first.slice(0, position - 1) + first.slice(position + 1))\\n      break outerLoop\\n    }\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"Tada!\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"BTW to be completely thorough, I should mention that with the fairly small amount of data involved in this problem, none of the optimizations I added matter. Running the code as above takes ~20ms. Changing \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"innerIndex\"), \" to start at 0 instead of \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"outerIndex + 1\"), \", changing the \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"sharedIndex\"), \" conditional to not look at \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"differenceCount\"), \", and removing the \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\"\n      }, \"break\"), \" statement slows it down to...~60ms. \"));\n    }\n  }]);\n\n  return MDXContent;\n}(React.Component);\n\nreturn MDXContent;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"4c59a18d-07b7-5328-ba62-36051155f98d","slug":"/advent-of-code-day-2","frontMatter":{"path":"/advent-of-code-day-2","title":"My Second Post","tags":["education","javascript","Advent of Code"]},"prev":null,"next":{"id":"bad906f4-932d-5a95-9701-97aba53cdcd4","parent":{"name":"2018-12-01-advent-of-code"},"code":{"scope":""},"frontmatter":{"path":"/advent-of-code-day-1","title":"My First Post","tags":["education","javascript","Advent of Code"]}}}}