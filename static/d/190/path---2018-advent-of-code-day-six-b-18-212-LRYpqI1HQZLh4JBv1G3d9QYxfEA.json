{"data":{"mdx":{"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"These geometry problems are tough.\"), mdx(\"p\", null, \"It starts with the usual data read, plus a bit of processing to turn each line into an array of two numbers:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nlet input = fs.readFileSync(`./input/day6.txt`, 'utf8')\\n  .trim()\\n  .split(\\\"\\\\n\\\")\\n  .map(line => line.split(', ').map(Number))\\n\")), mdx(\"p\", null, \"Then gather all the x values and all the y values and find maxes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const xMax = Math.max(...input.map(([x, y]) => x))\\nconst yMax = Math.max(...input.map(([x, y]) => y))\\n\")), mdx(\"p\", null, \"At first I thought I would have to iterate over the whole grid, measuring the distance from each point on the grid to the nearest point from the input. That was going to be a lot of calculation; the grid is about 350x350, meaning over a million points, and there are about 250 points in the input list. I didn't see an obvious solution for deciding which input was closest to a given grid point without calculating every distance. \"), mdx(\"p\", null, \"Instead I decided to measure outward, starting at each input point and finding its neighboring points, then all the neighbors of those points, etc. I would sort of build concentric circles around each input point, and each loop through the code would increase the radius of the circles. How would I know when to stop looping? I had no idea. What would I do when the expanding circles around each input point started to overlap? Not sure. What did I know how to do? Well, given a point, I could find the four points adjacent to it, and check to find which of them were on the grid:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const findNeighbors = ([x, y]) => {\\n  let prospects = [ [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1] ]\\n  return prospects.filter(([X, Y]) => X >= 0 && Y >= 0 && X <= xMax && Y <= xMax)\\n}\\n\")), mdx(\"p\", null, \"Once I found the nearest neighbors for an input, I'd need to store them somewhere. An object didn't seem like the right answer, because there was no clear candidate for a key to associate with each value. The other option was an array\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9cc5cc71-dce2-5e6a-977d-334313740f40","slug":"/2018-advent-of-code-day-six/","timeToRead":1,"wordCount":271,"frontMatter":{"date":null,"title":"","tags":null},"prev":{"id":"c46df0df-2d72-5d4d-bbcc-07440881ed2d","parent":{"name":"2018-advent-of-code-day-five"},"excerpt":"Not much code for day 5. Get the initial input: -and we're already 1/8 done. The key feature of the polymerization reaction described here…","fields":{"slug":"/2018-advent-of-code-day-five/"},"timeToRead":1,"wordCount":{"words":365},"frontmatter":{"date":null,"title":"","tags":null}},"next":{"id":"b7118581-8cfd-5918-8049-7800ffaeba3c","parent":{"name":"2018-advent-of-code-day-one"},"excerpt":"2018 Advent of Code, Day One Advent of Code  is a series of software puzzles released every year during Advent ^advent . There's a cute…","fields":{"slug":"/2018-advent-of-code-day-one/"},"timeToRead":4,"wordCount":{"words":1158},"frontmatter":{"date":"2019-05-04","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]}}}}