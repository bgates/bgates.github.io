{"data":{"mdx":{"id":"81397385-bc99-58b0-8260-7307c9d79350","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/advent-of-code-day-4\",\n  \"date\": \"2019-05-03\",\n  \"title\": \"2018 Advent of Code, Day 4\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Day Four has us figuring out when to sneak by a sleeping guard, based on a set of notes about when each guard starts a shift, falls asleep, and wakes up. The first step may look familiar:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst data = fs\\n  .readFileSync(`./input/day4.txt`, 'utf8')\\n  .trim()\\n  .split('\\\\n')\\n  .sort()\\n\")), mdx(\"p\", null, \"The input text file isn't sorted properly, but because each line starts with a datetime stamp, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".sort()\"), \" is able to get it in the right order.\"), mdx(\"p\", null, \"For part one, we need to find which minutes each guard is asleep. We also need to find which guard has the most minutes asleep. At first, I thought that meant I had to keep track of two pieces of information per guard, so I made a little object:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{ numberOfMinutesAsleep: 0, whichMinutes: [] }\\n\")), mdx(\"p\", null, \"Then I realized that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"numberOfMinutesAsleep\"), \" could be calculated by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"whichMinutes.length\"), \", so I simplified the object to have just one property:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{\\n  whichMinutes: []\\n}\\n\")), mdx(\"p\", null, \"Then I realized having an object just makes it a little harder to get to the array in which I'm keeping track of the minutes, so I ended up just using an array to represent the minutes a guard spends asleep.\"), mdx(\"p\", null, \"A guard may fall asleep and wake up multiple times during a shift. I decided to iterate over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \", checking each line to see whether it described a guard falling asleep, waking up, or the start of a new guard's shift:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"data.forEach(line => {\\n  if (line.includes('begins shift')) {\\n    //\\n  } else if (line.includes('falls asleep')) {\\n    //\\n  } else {\\n    //\\n  }\\n})\\n\")), mdx(\"p\", null, \"A guard's id is mentioned at the start of the shift; it's the numerical characters after a '#'. I can get that id in the first condition, though I need to initialize a variable outside the whole \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".forEach()\"), \" callback function so the id can persist to the next time through:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let currentGuardId\\ndata.forEach(line => {\\n  if (line.includes('begins')) {\\n    currentGuardId = line.match(/#(\\\\d+)/)[1]\\n    if (!guards[currentGuardId]) {\\n      guards[currentGuardId] = []\\n    }\\n  } else if (line.includes('falls')) {\\n...\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".match()\"), \" takes a regular expression as an argument. I used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/#(\\\\d)+/\"), \" as the regular expression. That sequence of characters means \\\"a literal '#', then one or more digits - and hold on to the digits for later\\\". The return value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".match()\"), \" is an array, and the 1st element is the first captured group from the match (the digits I held on to). That's how I get the id out of the line. I use the id as a key in my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"guards\"), \" object. If it's the first time I've seen the id, I initialize a value for it as an empty array. That will hold the list of minutes the guard spends asleep.\"), mdx(\"p\", null, \"I can do basically the same thing to find the time a guard falls asleep:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let currentGuardId\\nlet sleepStart\\ndata.forEach(line => {\\n  if (line.includes('begins')) {\\n    currentGuardId = line.match(/#(\\\\d+)/)[1]\\n    if (!guards[currentGuardId]) {\\n      guards[currentGuardId] = []\\n    }\\n  } else if (line.includes('falls')) {\\n    sleepStart = Number(line.match(/:(\\\\d+)/)[1])\\n  } else {\\n...\\n\")), mdx(\"p\", null, \"Once again, a regular expression capture group extracts some digits from a string. This time, I have to feed that value into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" function, because I will need to treat it as a number in a minute (so to speak). I also initialized the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sleepStart\"), \" variable outside of the callback function so it survives from one loop to the next.\"), mdx(\"p\", null, \"If a line doesn't say a guard's shift begins and it doesn't say a guard falls asleep, it must say the guard wakes up. These things happen in order, so by the time I reach a line that tells me when a guard wakes, I must already have values for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentGuardId\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sleepStart\"), \". I can use those values, along with the time the guard wakes up, to say which minutes the guard has slept during the latest nap:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"  } else if (line.includes('falls')) {\\n    sleepStart = Number(line.match(/:(\\\\d+)/)[1])\\n  } else {\\n    const wakeTime = Number(line.match(/:(\\\\d+)/)[1])\\n    const newMinutes = (new Array(wakeTime)).fill(1).map((_, i) => i).slice(sleepStart,)\\n    const guard = guards[currentGuardId]\\n    guards[currentGuardId] = [ ...guard, ...newMinutes ]\\n  }\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wakeTime\"), \" works exactly the same way \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sleepStart\"), \" did. Those two variables together mark the start and end of the interval the guard was asleep. I can use them together to make \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"newMinutes\"), \", the array with each minute in that interval. First \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new Array(wakeTime)\"), \" makes an array with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wakeTime\"), \" slots in it. (Due to a quirk in JavaScript, I can't do anything useful with that array right off, so I have to fill the empty slots in it by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".fill(1)\"), \", which gives me an array of all 1's.) I can convert the array to a sequence of integers by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".map()\"), \" and returning the index value of each element in the array. At that point, I'll have an array of 0 to just before \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wakeTime\"), \". For example, if the guard woke up at 12:06, the array will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0, 1, 2, 3, 4, 5]\"), \". I still need to remove the numbers at the front end from before the guard fell asleep, which is what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".slice(sleepStart,)\"), \" does.\"), mdx(\"p\", null, \"Once I have the array with the minutes the guard slept during that nap, I spread them into the array stored at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"guards[currentGuardId]\"), \". Then it is the work of but a moment to find the id of the guard who slept the most. I have to turn the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"guards\"), \" object into an array of the object's values, then map those values to their lengths, then get the biggest length. That will tell me the largest number of minutes any guard spent asleep. Then iterate over the keys in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"guards\"), \" to find the guard who slept that much:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const times = Object.values(guards).map(guard => guard.length)\\nconst maxTime = Math.max(...times)\\nconst sleepyGuardId = Object.keys(guards).find(\\n  guardId => guards[guardId].length === maxTime\\n)\\n\")));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"81397385-bc99-58b0-8260-7307c9d79350","slug":"/advent-of-code-day-4","timeToRead":3,"wordCount":760,"frontMatter":{"path":"/advent-of-code-day-4","date":"2019-05-03","title":"2018 Advent of Code, Day 4","tags":["education","javascript","Advent of Code"]},"prev":{"id":"70e13885-5d94-59ec-8838-bfdc90bb00a4","parent":{"name":"2018-12-03-advent-of-code-day-3"},"excerpt":"Today's problem involves a lot of squares, and it would be easier if I could just see it, so I ended up making some drawings by the time I…","timeToRead":9,"wordCount":{"words":2338},"frontmatter":{"path":"/advent-of-code-day-3","date":"2019-05-04","title":"2018 Advent of Code, Day 3","tags":["education","javascript","Advent of Code"]}},"next":null}}