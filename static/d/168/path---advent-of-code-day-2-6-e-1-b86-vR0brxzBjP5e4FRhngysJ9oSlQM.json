{"data":{"mdx":{"id":"4c59a18d-07b7-5328-ba62-36051155f98d","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/advent-of-code-day-2\",\n  \"date\": \"2019-05-04\",\n  \"order\": 3,\n  \"title\": \"2018 Advent of Code, Day 2\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Day Two focuses on finding patterns in strings.\"), mdx(\"p\", null, \"For the first puzzle, we're asked to take a set of strings of letters referred to as \\\"ids\\\" and identify ids that contain duplicate letters. More specifically, count\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"how many ids have \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"at least one letter that appears exactly twice\"), \", and\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"how many ids have \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"at least one letter that appears exactly three times\"), \".\")), mdx(\"p\", null, \"For example,\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abcdef\"), \" has no repeats. (I love \", mdx(\"a\", {\n    href: \"https://www.youtube.com/watch?v=emvySA1-3t8\"\n  }, \"explanations that start at that level\"), \".)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abcabc\"), \" has letters that appear exactly twice. It doesn't matter how many letters appear exactly twice, just that at least one does.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abcccf\"), \" has a letter that appears exactly three times - only one, but that's enough to count.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"aabbbc\"), \" has a letter that appears twice \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"and\"), \" a letter that appears three times, so this string counts for both categories.\")), mdx(\"p\", null, \"If that was the whole set of ids, the final count would be two \\\"appears exactly twice\\\"s and two \\\"appears exactly three times\\\"s, and we wouldn't need software to deal with it. Fortunately, there are 250 ids, so I can get a blog post out of this.\"), mdx(\"p\", null, \"Since the input data was once again made available as a text file, I was able to reuse some code from yesterday:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst input = fs.readFileSync(`./input/day2.txt`, 'utf8').trim()\\nconst ids = input.split('\\\\n')\\n\")), mdx(\"p\", null, \"That gets me to a good place on the input side - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ids\"), \" is an array of strings, and I know there are lots of things I can do with a data structure like that.\"), mdx(\"p\", null, \"Next I'll take a minute to think about what I want to end up with. A few paragraphs ago I wrote about keeping count for strings with letters that appeared twice, and for strings with letters that appeared three times. That's two independent pieces of data, so I'll need some kind of container. The most fundamental in JavaScript are objects and arrays. Either of those would work here - there will only ever be two pieces of information, so the speed of access that was a concern yesterday doesn't matter in this problem. Even so, if there's not a good reason to choose an array, I prefer to use an object, because objects let me label the data I'm storing. That's the reasoning that led me to this data structure:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let counts = {\\n  countOfIdsWithDoubles: 0,\\n  countOfIdsWithTriples: 0,\\n}\\n\")), mdx(\"p\", null, \"I'm not super happy with the keys in that object; the length makes them a bit tough to read. On the bright side, I nailed the values - the initial counts are zero. Go, me.\"), mdx(\"p\", null, \"OK, now I know where I'm starting (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ids\"), \", the array of strings) and where I want to end up (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \", an object), so I just need to put in the middle bits. I can get from an array to an object with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \"; that method showed up yesterday, as a way to add together all the numbers in an array called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sequence\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sum = sequence.reduce((total, current) => total + current, 0)\\n\")), mdx(\"p\", null, \"There are a few differences between how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" was used for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum\"), \" and how I need to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" for this problem. For one thing, I need to keep track of two numbers, not just one, so the initial value will have to be different. For another, I'm not just adding two numbers together to get the return value from the callback function. I'm keeping track of two numbers, and I might not be changing the numbers for every element in the array. I only want to count the ids with repeating letters, so I'll need some kind of conditional logic.\"), mdx(\"p\", null, \"I already have my initial value - it's the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \" object. The bigger problem is to figure out what to do with that object in the callback function. The basic outline I have in mind is this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  const hasDouble = // figure out if any letter appears twice in `id`\\n  if (hasDouble) {\\n    // increase the count of ids with repeat letters\\n  }\\n  const hasTriple = // figure out if any letter appears three times in `id`\\n  if (hasTriple) {\\n    // increase the count of ids with letters that appear 3x\\n  }\\n  return // an object to use for the next `total`\\n}, counts)\\n\")), mdx(\"p\", null, \"This use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" looks a lot different than the use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" to calculate a sum. That's because the callback function here spreads over several lines, from the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{\"), \" to the last \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"}\"), \". Still, I'm using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" with two arguments, a callback function and an initial value (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \").\"), mdx(\"p\", null, \"I don't know yet how I'm going to calculate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasDouble\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasTriple\"), \", but I do know what to do with my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \" object when either of those conditions is met. Since I'm using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \" as the initial value, it gets inside the callback function under the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"total\"), \". I can get each count out of the object with destructuring:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  let {\\n    countOfIdsWithDoubles,\\n    countOfIdsWithTriples\\n  } = total\\n  ...\\n\")), mdx(\"p\", null, \"Then I can increment them as appropriate:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const hasDouble = // TODO\\nif (hasDouble) {\\n  countOfIdsWithDoubles += 1\\n}\\nconst hasTriple = // TODO\\nif (hasTriple) {\\n  countOfIdsWithTriples += 1\\n}\\n\")), mdx(\"p\", null, \"Once I have decided whether or not each of those variables should be incremented, I can recombine them into an object to return as the new value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"total\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  let {\\n    countOfIdsWithDoubles,\\n    countOfIdsWithTriples\\n  } = total\\n  const hasDouble = // TODO\\n  if (hasDouble) {\\n    countOfIdsWithDoubles += 1\\n  }\\n  const hasTriple = // TODO\\n  if (hasTriple) {\\n    countOfIdsWithTriples += 1\\n  }\\n  return {\\n    countOfIdsWithDoubles,\\n    countOfIdsWithTriples\\n  }\\n}, count)\\n\")), mdx(\"p\", null, \"Now all that's left is calculating what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasDouble\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasTriple\"), \" are.\"), mdx(\"p\", null, \"Figuring out if \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" letter in an id repeats is a bit hard, so I don't want to do it. \", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-1\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }), \"1\")), \" I think I can sneak up on the problem by solving a related but simpler problem, like...does the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"first\"), \" letter in the id repeat?\"), mdx(\"p\", null, \"Well, how can I figure that out?\"), mdx(\"h3\", null, \"String => Boolean\"), mdx(\"p\", null, \"I have an id, which is a string. I want to get an answer to \\\"does it repeat\\\", which will be a boolean (true or false). Hmmm. Before I get to the boolean, I could try to find an answer to \\\"how many times does this letter appear\\\". The answer to that question will be a number. (I can get to the boolean from there by asking whether the number equals two.) Starting with my string, id, I want to get to a number. I don't know exactly how to do that. I do know how to turn an array into a number. I mean, I've done it before. And I can get an array out of my string:\"), mdx(\"h3\", null, \"String => Array\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const letters = id.split('')\\n\")), mdx(\"p\", null, \"Then I can get the first letter easily enough\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const firstLetter = letters[0]\\n\")), mdx(\"p\", null, \"I can use it to turn the array into a number, by going through all the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"letters\"), \", and keeping count of how many times I see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"firstLetter\"), \". To be excruciatingly specific, I'll start my total at zero, look at every letter in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"letters\"), \" one at a time, and if I see a letter that's the same as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"firstLetter\"), \", I'll add one to the total. Otherwise, I'll leave the total where it was.\"), mdx(\"h3\", null, \"Array => Number\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const count = letters.reduce(\\n  (current, total) => (current === firstLetter ? total + 1 : total),\\n  0\\n)\\n\")), mdx(\"p\", null, \"Getting from the number to a boolean is easier:\"), mdx(\"h3\", null, \"Number => Boolean\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const firstLetterAppearsTwice = count === 2\\n\")), mdx(\"p\", null, \"Putting that all together,\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const letters = id.split('')\\nconst firstLetter = letters[0]\\nconst count = letters.reduce(\\n  (current, total) => (current === firstLetter ? total + 1 : total),\\n  0\\n)\\nconst firstLetterAppearsTwice = count === 2\\n\")), mdx(\"p\", null, \"And that solves the problem! Or at least, it solves what I called the simpler problem of finding if the first letter repeats. I still have the problem of finding if \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" letter repeats. That means I have to take the logic I used to turn \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"letters[0]\"), \" into a boolean, and apply it to every letter in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"letters\"), \". Then, if any letter ends up with a boolean of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \", I can say that some letter repeats. I can do that with the array method called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"some\"), \", which looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const letters = id.split('')\\nconst hasDouble = letters.some(letter => {\\n  const count = letters.reduce(\\n    (current, total) => (current === letter ? total + 1 : total),\\n    0\\n  )\\n  return count === 2\\n})\\n\")), mdx(\"p\", null, \"Checking if a letter appears three times is almost exactly the same:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const hasTriple = letters.some(letter => {\\n  const count = letters.reduce(\\n    (current, total) => (current === letter ? total + 1 : total),\\n    0\\n  )\\n  return count === 3\\n})\\n\")), mdx(\"p\", null, \"Let's see how to use those in the callback for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \", in the place that was marked \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"//TODO\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  let { countOfIdsWithDoubles, countOfIdsWithTriples } = total\\n  const letters = id.split('')\\n  const hasDouble = letters.some(letter => {\\n    const count = letters.reduce(\\n      (current, total) => (current === letter ? total + 1 : total),\\n      0\\n    )\\n    return count === 2\\n  })\\n  if (hasDouble) {\\n    countOfIdsWithDoubles += 1\\n  }\\n  const hasTriple = letters.some(letter => {\\n    const count = letters.reduce(\\n      (current, total) => (current === letter ? total + 1 : total),\\n      0\\n    )\\n    return count === 3\\n  })\\n  if (hasTriple) {\\n    countOfIdsWithTriples += 1\\n  }\\n  return {\\n    countOfIdsWithDoubles,\\n    countOfIdsWithTriples,\\n  }\\n}, counts)\\n\")), mdx(\"p\", null, \"That works! Now I can tidy up a bit. There's a lot of duplication between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasDouble\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasTriple\"), \"; they're identical except for the number. I can pull that out into a function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const appearNTimes = n =>\\n  letters.some(\\n    const count = letters.reduce(\\n      (current, total) => (current === letter ? total + 1 : total),\\n      0\\n    )\\n    return count === n\\n  )\\n\")), mdx(\"p\", null, \"That's a function that takes a single argument, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \", and returns all of the code that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasDouble\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasTriple\"), \" had in common. I can use the function to create those expressions:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const hasDouble = appearNTimes(2)\\nconst hasTriple = appearNTimes(3)\\n\")), mdx(\"p\", null, \"That slims things down:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  let { countOfIdsWithDoubles, countOfIdsWithTriples } = total\\n  const letters = id.split('')\\n  const appearNTimes = n =>\\n    letters.some(letter => {\\n      const count = letters.reduce(\\n        (current, total) => (current === letter ? total + 1 : total),\\n        0\\n      )\\n      return count === n\\n    })\\n  const hasDouble = appearNTimes(2)\\n  if (hasDouble) {\\n    countOfIdsWithDoubles += 1\\n  }\\n  const hasTriple = appearNTimes(3)\\n  if (hasTriple) {\\n    countOfIdsWithTriples += 1\\n  }\\n  return {\\n    countOfIdsWithDoubles,\\n    countOfIdsWithTriples,\\n  }\\n}, counts)\\n\")), mdx(\"p\", null, \"This could be refactored some more, but I tend to obsess over that kind of thing, and I haven't started on the day's second puzzle. The second puzzle is shorter to describe, both for the problem and the solution. The problem is to find two ids that are identical except for one letter, and then print out the letters those two ids have in common. On to the solution.\"), mdx(\"p\", null, mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-2\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-2\",\n    \"className\": \"footnote-ref\"\n  }), \"2\")), \" And he ended the blog forever.\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-1\"\n  }), \"the end\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")), mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-2\"\n  }), \"the end\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-2\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"4c59a18d-07b7-5328-ba62-36051155f98d","slug":"/advent-of-code-day-2","timeToRead":5,"wordCount":1255,"frontMatter":{"path":"/advent-of-code-day-2","date":"2019-05-04","title":"2018 Advent of Code, Day 2","tags":["education","javascript","Advent of Code"]},"prev":{"id":"669d3616-8c2d-5cda-b661-db2476522aae","parent":{"name":"2018-12-01-advent-of-code-day-1-part-2"},"excerpt":"Part Two gets tougher. The goal of Part Two is to use the same list of changes from Part One and find the first frequency that repeats. It…","timeToRead":2,"wordCount":{"words":599},"frontmatter":{"path":"/advent-of-code-day-1-part-2","date":"2019-05-04","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]}},"next":{"id":"81397385-bc99-58b0-8260-7307c9d79350","parent":{"name":"2018-12-04-advent-of-code-day-4"},"excerpt":"Day Four has us figuring out when to sneak by a sleeping guard, based on a set of notes about when each guard starts a shift, falls asleep…","timeToRead":3,"wordCount":{"words":760},"frontmatter":{"path":"/advent-of-code-day-4","date":"2019-05-03","title":"2018 Advent of Code, Day 4","tags":["education","javascript","Advent of Code"]}}}}