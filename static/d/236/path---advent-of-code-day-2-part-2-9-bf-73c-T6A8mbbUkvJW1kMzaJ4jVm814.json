{"data":{"mdx":{"id":"23a17621-c678-590b-adf1-51ffa50346a6","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/advent-of-code-day-2-part-2\",\n  \"date\": \"2019-05-02\",\n  \"title\": \"2018 Advent of Code, Day 2, Part 2\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The problem is to find two ids that are identical except for one letter, and then print out the letters those two ids have in common. I couldn't see an elegant way to do this. Because I need to compare pairs of ids, I need to have two nested iterations, one inside the other (a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop inside another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop or a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".forEach()\"), \" inside another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".forEach()\"), \"). I don't want to compare \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"every\"), \" pair, though; when I find the two ids I want, I can stop. That's easier to do from inside a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop than from inside a call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".forEach()\"), \". I also don't want to compare any pair twice; once I compare the first to the second, I don't need to compare the second to the first. I have to make sure the second, inner \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop doesn't look at any elements that have already been looked at in the outer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop. To do that, I can have the inner loop's index start at the next number after whatever the outer loop's index's value is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    // compare one id to another\\n  }\\n}\\n\")), mdx(\"p\", null, \"The point of having those indexes is to identify two id values I want to compare:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    const [first, second] = [ids[outerIndex], ids[innerIndex]]\\n    // compare first to second\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now I want to compare the letters in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"second\"), \". Since I want to compare the letters at the same position in both ids, I need one more \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    const [first, second] = [ids[outerIndex], ids[innerIndex]]\\n    for (let sharedIndex = 0; sharedIndex < first.length; sharedIndex += 1) {\\n      // compare a letter in first to the letter at the same index in second\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"I'm interested in finding the two id values that are different at only one position. That means (a) I need to keep track of how many positions are different, and (b) once a pair is different at two positions, I can go on to the next pair. I can take care of (b) by adding to the innermost \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop's condition:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    const [first, second] = [ids[outerIndex], ids[innerIndex]]\\n    let differenceCount = 0\\n    for (\\n      let sharedIndex = 0;\\n      sharedIndex < first.length && differenceCount < 2;\\n      sharedIndex += 1\\n    ) {\\n      if (first[sharedIndex] !== second[sharedIndex]) {\\n        differenceCount += 1\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now the innermost \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop will continue only as long as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sharedIndex < first.length\"), \" AND \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"differenceCount < 2\"), \". OK, we're comparing each pair of ids in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ids\"), \" array, and counting how many letters are different in each pair. If the pair is different in more than one position, we bail out of the comparison and move on. What if we make it all the way to the end of one pair of ids and they're different in only one position? We should break out of the loop. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" statement by itself isn't enough, because that will only break out of the inner loop. Something I learned while solving this is that you can give a block a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"label\"), \", which looks like an object key. Then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" can be given the label of the block to break out of. Here's what that looks like, with the label \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"outerLoop\"), \" added to...the outer loop:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"outerLoop: for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    const [first, second] = [ids[outerIndex], ids[innerIndex]]\\n    let differenceCount = 0\\n    for (\\n      let sharedIndex = 0;\\n      sharedIndex < first.length && differenceCount < 2;\\n      sharedIndex += 1\\n    ) {\\n      if (first[sharedIndex] !== second[sharedIndex]) {\\n        differenceCount += 1\\n      }\\n    }\\n    if (differenceCount === 1) {\\n      console.log('found them!', first, second)\\n      break outerLoop\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Getting close! In a pinch, you could look closely at that console output and type out one of the ids without the letter that's different between the two. That's actually how I submitted my solution to Advent of Code. To be thorough, here are the last steps to get the whole problem solved by software. We'll need to identify the position at which the two ids are different, then log out one of the ids with that position removed:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"    let differenceCount = 0\\n    let position\\n    for (let sharedIndex = 0; sharedIndex < first.length && differenceCount < 2; sharedIndex += 1) {\\n      if (first[sharedIndex] !== second[sharedIndex]) {\\n        differenceCount += 1\\n        position = sharedIndex\\n      }\\n    }\\n    if (differenceCount === 1) {\\n      console.log(first.slice(0, position - 1) + first.slice(position + 1))\\n      break outerLoop\\n    }\\n\")), mdx(\"p\", null, \"Tada!\"), mdx(\"p\", null, \"BTW to be completely thorough, I should mention that with the fairly small amount of data involved in this problem, none of the optimizations I added matter. Running the code as above takes ~20ms. Changing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"innerIndex\"), \" to start at 0 instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"outerIndex + 1\"), \", changing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sharedIndex\"), \" conditional to not look at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"differenceCount\"), \", and removing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" statement slows it down to...~60ms.\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"23a17621-c678-590b-adf1-51ffa50346a6","slug":"/advent-of-code-day-2-part-2","timeToRead":2,"wordCount":554,"frontMatter":{"path":"/advent-of-code-day-2-part-2","date":"2019-05-02","title":"2018 Advent of Code, Day 2, Part 2","tags":["education","javascript","Advent of Code"]},"prev":{"id":"70e13885-5d94-59ec-8838-bfdc90bb00a4","parent":{"name":"2018-12-03-advent-of-code-day-3"},"excerpt":"Today's problem involves a lot of squares, and it would be easier if I could just see it, so I ended up making some drawings by the time I…","timeToRead":9,"wordCount":{"words":2338},"frontmatter":{"path":"/advent-of-code-day-3","date":"2019-05-03","title":"2018 Advent of Code, Day 3","tags":["education","javascript","Advent of Code"]}},"next":{"id":"bad906f4-932d-5a95-9701-97aba53cdcd4","parent":{"name":"2018-12-01-advent-of-code"},"excerpt":"2018 Advent of Code, Day 1 Advent of Code  is a series of software puzzles released every year during Advent ^advent . There's a cute…","timeToRead":4,"wordCount":{"words":1158},"frontmatter":{"path":"/advent-of-code-day-1","date":"2019-04-25","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]}}}}