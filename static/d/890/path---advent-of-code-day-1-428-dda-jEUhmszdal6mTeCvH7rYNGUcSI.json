{"data":{"mdx":{"id":"bad906f4-932d-5a95-9701-97aba53cdcd4","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/advent-of-code-day-1\",\n  \"slug\": \"/first-post\",\n  \"date\": \"2019-04-25\",\n  \"order\": 1,\n  \"title\": \"Solving Problems with Code\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"2018 Advent of Code, Day 1\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.adventofcode.com\"\n  }), \"Advent of Code\"), \" is a series of software puzzles released every year during Advent\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-advent\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-advent\",\n    \"className\": \"footnote-ref\"\n  }), \"advent\")), \". There's a cute Christmas-themed story that ties the puzzles together. Every day at midnight\", mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-midnight\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-midnight\",\n    \"className\": \"footnote-ref\"\n  }), \"midnight\")), \", a link to the day's first puzzle goes live on the Advent of Code site. When you solve that puzzle, you get a link to a second puzzle which builds on the first. The problems are great examples of the kinds of algorithmic challenges that can come up in large scale production code, but almost never happen in personal projects. That means they resemble the whiteboard job interview stuff that nobody I know likes. The critical difference is that Christmas is a much more enjoyable theme than My Career and Therefore Life Are At Stake Why Can't I Do This Damn You Whiteboard Damn You to Hell.\"), mdx(\"p\", null, \"I think the Advent of Code is especially well-suited for bootcamp grads who have been out for a while.\"), mdx(\"h2\", null, \"The Problem\"), mdx(\"p\", null, \"The first problem of Day One amounts to reading a set of numerical frequency changes and calculating where the frequency ends up. Quoting from the site:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"For example, if the device displays frequency changes of\\n+1, -2, +3, +1, then starting from a frequency of zero,\\nthe following changes would occur:\\n===\\nCurrent frequency  0, change of +1; resulting frequency  1.\\nCurrent frequency  1, change of -2; resulting frequency -1.\\nCurrent frequency -1, change of +3; resulting frequency  2.\\nCurrent frequency  2, change of +1; resulting frequency  3.\\nIn this example, the resulting frequency is 3.\\n===\\nHere are other example situations:\\n\\n+1, +1, +1 results in  3\\n+1, +1, -2 results in  0\\n-1, -2, -3 results in -6\\n\")), mdx(\"p\", null, \"The problem includes a link to a file that just has numbers, some positive and some negative, each on its own line, like the following Example Data\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"-19\\n+3\\n+7\\n-1\\n+21\\n\")), mdx(\"p\", null, \"OK, here's how I solved it:\"), mdx(\"h2\", null, \"Dealing with Data Types\"), mdx(\"h3\", null, \"File => String\"), mdx(\"p\", null, \"The first problem I have is that JavaScript doesn't see things the way we do. When I open the file that has numbers in it, it looks to me like a list of numbers. But to JavaScript, it's just a file. To get anywhere, I need to get JavaScript to recognize the list of numbers in the file.\"), mdx(\"p\", null, \"First I saved the file with the numbers as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"day1.txt\"), \". Then I opened a new file, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"day1.js\"), \", and wrote some Node code to read the data file:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst input = fs.readFileSync('./input/day1.txt', 'utf8').trim()\\n\")), mdx(\"p\", null, \"The first line lets me use the Node module \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fs\"), \", which handles file operations synchronously (so I don't have to deal with asynchronous stuff like promises or async/await). The second line reads that file and holds it in a variable called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \", which is one long, multi-line string.\"), mdx(\"p\", null, \"That's better. I know more about dealing with strings in JavaScript than I do about dealing with files.\"), mdx(\"h3\", null, \"String => Array of Strings\"), mdx(\"p\", null, \"The next thing I want to do is to turn the one string into a bunch of numbers. I know \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" is a multi-line string, with each number represented on its own line. I'd like to split the string into a lot of pieces, where each piece represents one line. I know the end of a line in JavaScript is represented by a newline character, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\n\"), \". I also know there's a method that can be invoked on a JavaScript string that splits it up:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sequenceOfStrings = input.split('\\\\n')\\n// sequenceOfStrings is an array of strings\\n\")), mdx(\"p\", null, \"Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" is a string with a \\\"number\\\" on each line, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input.split(\\\"\\\\n\\\")\"), \" returns an array with the \\\"number\\\"s as elements. The quotes around \\\"number\\\" are there to emphasize that at this point, they're not actual numbers yet - they're still strings, like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" was. If I was working with the Example Data I showed above, my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sequenceOfStrings\"), \" would look like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[\\\"-19\\\", \\\"+3\\\", \\\"+7\\\", \\\"-1\\\", \\\"+21\\\"]\"), \". So far, I managed to turn a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"file\"), \" into a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"string\"), \", and then turn that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"one\"), \" string into an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \" of strings. Now I want to get an array, but instead of an array of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strings\"), \", I want an array of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"numbers\"), \".\"), mdx(\"h3\", null, \"Array of Strings => Array of Numbers\"), mdx(\"p\", null, \"In order to get the array I want, I need to transform every element in the array I have - transform from a string that looks like a number, into the number that the string looks like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"/*elements in */   /*elements in */\\n/*array I have*/   /*array I want*/\\n\\\"-19\\\"               -19\\n\\\"+3\\\"                  3\\n\\\"+7\\\"                  7\\n\\\"-1\\\"                 -1\\n\\\"+21\\\"                21\\n\")), mdx(\"h4\", null, \"Array.map\"), mdx(\"p\", null, \"I want to\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"create an array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"that is the same size as an array I have\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"by transforming each element in the array I have\")), mdx(\"p\", null, \"The way to do that in JavaScript is by using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" method on the array I have. I'll also need a function to do each of the transformations. There's a built-in function in JavaScript that does what I want:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"Number('-19') // returns -19\\nNumber('+3') // returns 3\\n\")), mdx(\"p\", null, \"I can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" function together with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" method to turn the array of strings I have into the array of numbers I want. You may have seen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" illustrated by examples like this, which transforms each element in the array by multiplying it by five:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \";[1, 2, 3].map(n => n * 5) // returns [5, 10, 15]\\n\")), mdx(\"p\", null, \"where the transformation function is written as an arrow function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n => n * 5\"), \". With that in mind, I could write my transformation using my example array and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" function like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \";['-19', '+3', '+7', '-1', '+21'].map(n => Number(n))\\n\")), mdx(\"p\", null, \"That transformation function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n => Number(n)\"), \", has a parameter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \", and returns whatever \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number(n)\"), \" is. But I could say the same thing about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" by itself. It's a function that takes a parameter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" and returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number(n)\"), \". That means I can write my transformation a little more concisely:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \";['-19', '+3', '+7', '-1', '+21'].map(Number)\\n\")), mdx(\"p\", null, \"When I realized I could do that, it immediately became my favorite thing about JavaScript. I just feel so baller when I can write such short, expressive...expressions. Anyway, that's how to transform the array of strings into an array of numbers. There's just one more step.\"), mdx(\"h3\", null, \"Array of Numbers => Number\"), mdx(\"p\", null, \"Turning an array into a single value is the reason for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" method, and adding all the numbers in an array into a single sum is probably the most common example used to illustrate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sum = [-19, 3, 7, -1, 21].reduce((total, current) => total + current, 0)\\n\")), mdx(\"p\", null, \"And that's the last step in solving Part One. All of the above writing can be summed up with these lines of code:\"), mdx(\"h2\", null, \"The Solution\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst input = fs.readFileSync('./input/day1.txt', 'utf8').trim()\\nconst sequenceOfStrings = input.split('\\\\n')\\nconst sequenceOfNumbers = sequenceOfStrings.map(Number)\\nconst answer = sequenceOfNumbers.reduce((total, current) => total + current, 0)\\n\")), mdx(\"p\", null, \"Or without the intermediate variables:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst answer = fs\\n  .readFileSync('./input/day1.txt', 'utf8')\\n  .trim()\\n  .split('\\\\n')\\n  .map(Number)\\n  .reduce((total, current) => total + current, 0)\\n\")), mdx(\"p\", null, \"Looking back, the most important things I needed to know to get to my solution were that the answer had to be a single number, the initial data was in a file, and there are ways to get from one data type to another.\"), mdx(\"p\", null, \"Part Two gets tougher.\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-advent\"\n  }), \"Traditionally, the period between the fourth Sunday before Christmas and Christmas itself; here, simply December 1-25.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-advent\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")), mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-midnight\"\n  }), \"Eastern Standard Time. Developers from all over the world compete to see who can solve these puzzles the fastest, and the only reliable way to measure that is to open the puzzles to the whole world at once.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-midnight\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"bad906f4-932d-5a95-9701-97aba53cdcd4","slug":"/advent-of-code-day-1","frontMatter":{"path":"/advent-of-code-day-1","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]},"prev":null,"next":{"id":"669d3616-8c2d-5cda-b661-db2476522aae","parent":{"name":"2018-12-01-advent-of-code-day-1-part-2"},"code":{"scope":""},"frontmatter":{"path":"/advent-of-code-day-1-part-2","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]}}}}