{"data":{"mdx":{"id":"4c59a18d-07b7-5328-ba62-36051155f98d","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/advent-of-code-day-2\",\n  \"date\": \"2019-04-17\",\n  \"title\": \"2018 Advent of Code, Day 2\",\n  \"tags\": [\"education\", \"javascript\", \"Advent of Code\"],\n  \"excerpt\": \"A preview\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Day Two focuses on finding patterns in strings.\"), mdx(\"p\", null, \"For the first puzzle, we're asked to take a set of strings of letters referred to as \\\"ids\\\" and identify ids that contain duplicate letters. More specifically, count\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"how many ids have \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"at least one letter that appears exactly twice\"), \", and\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"how many ids have \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"at least one letter that appears exactly three times\"), \".\")), mdx(\"p\", null, \"For example,\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abcdef\"), \" has no repeats. (I love \", mdx(\"a\", {\n    href: \"https://www.youtube.com/watch?v=emvySA1-3t8\"\n  }, \"explanations that start at that level\"), \".)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abcabc\"), \" has letters that appear exactly twice. It doesn't matter how many letters appear exactly twice, just that at least one does.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"abcccf\"), \" has a letter that appears exactly three times - only one, but that's enough to count.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"aabbbc\"), \" has a letter that appears twice \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"and\"), \" a letter that appears three times, so this string counts for both categories.\")), mdx(\"p\", null, \"If that was the whole set of ids, the final count would be two \\\"appears exactly twice\\\"s and two \\\"appears exactly three times\\\"s, and we wouldn't need software to deal with it. Fortunately, there are 250 ids, so I can get a blog post out of this.\"), mdx(\"p\", null, \"Since the input data was once again made available as a text file, I was able to reuse some code from yesterday:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fs = require('fs')\\nconst input = fs.readFileSync(`./input/day2.txt`, 'utf8').trim()\\nconst ids = input.split('\\\\n')\\n\")), mdx(\"p\", null, \"That gets me to a good place on the input side - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ids\"), \" is an array of strings, and I know there are lots of things I can do with a data structure like that.\"), mdx(\"p\", null, \"Next I'll take a minute to think about what I want to end up with. A few paragraphs ago I wrote about keeping count for strings with letters that appeared twice, and for strings with letters that appeared three times. That's two independent pieces of data, so I'll need some kind of container. The most fundamental in JavaScript are objects and arrays. Either of those would work here - there will only ever be two pieces of information, so the speed of access that was a concern yesterday doesn't matter in this problem. Even so, if there's not a good reason to choose an array, I prefer to use an object, because objects let me label the data I'm storing. That's the reasoning that led me to this data structure:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let counts = {\\n  countOfIdsWithDoubles: 0,\\n  countOfIdsWithTriples: 0,\\n}\\n\")), mdx(\"p\", null, \"I'm not super happy with the keys in that object; the length makes them a bit tough to read. On the bright side, I nailed the values - the initial counts are zero. Go, me.\"), mdx(\"p\", null, \"OK, now I know where I'm starting (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ids\"), \", the array of strings) and where I want to end up (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \", an object), so I just need to put in the middle bits. I can get from an array to an object with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \"; that method showed up yesterday, as a way to add together all the numbers in an array called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sequence\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const sum = sequence.reduce((total, current) => total + current, 0)\\n\")), mdx(\"p\", null, \"There are a few differences between how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" was used for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sum\"), \" and how I need to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" for this problem. For one thing, I need to keep track of two numbers, not just one, so the initial value will have to be different. For another, I'm not just adding two numbers together to get the return value from the callback function. I'm keeping track of two numbers, and I might not be changing the numbers for every element in the array. I only want to count the ids with repeating letters, so I'll need some kind of conditional logic.\"), mdx(\"p\", null, \"I already have my initial value - it's the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \" object. The bigger problem is to figure out what to do with that object in the callback function. The basic outline I have in mind is this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  const hasDouble = // figure out if any letter appears twice in `id`\\n  if (hasDouble) {\\n    // increase the count of ids with repeat letters\\n  }\\n  const hasTriple = // figure out if any letter appears three times in `id`\\n  if (hasTriple) {\\n    // increase the count of ids with letters that appear 3x\\n  }\\n  return // an object to use for the next `total`\\n}, counts)\\n\")), mdx(\"p\", null, \"This use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" looks a lot different than the use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" to calculate a sum. That's because the callback function here spreads over several lines, from the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{\"), \" to the last \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"}\"), \". Still, I'm using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" with two arguments, a callback function and an initial value (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \").\"), mdx(\"p\", null, \"I don't know yet how I'm going to calculate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasDouble\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasTriple\"), \", but I do know what to do with my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \" object when either of those conditions is met:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"if (hasDouble) {\\n  // increase the count of ids with repeat letters\\n  const countOfIdsWithDoubles = counts.countOfIdsWithDoubles + 1\\n  counts = {\\n    ...counts,\\n    countOfIdsWithDoubles,\\n  }\\n}\\n\")), mdx(\"p\", null, \"One thing that could affect \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counts\"), \" is if a string has any letters that appear twice. I have some intuition that I want to write a function to check that. That's because I'll also have to check if a string has any letters that appear three times, and those tasks sound so similar, I bet I'll be able to reuse some code between them.\"), mdx(\"p\", null, \"I'm not worried about how exactly this new function will fit in the callback function for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".reduce()\"), \". It's enough to know that I need to check a string for repeated letters. That sounds like the new function will take one argument (the string) and return a boolean (because the question \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"are there letters that appear twice?\"), \" is answered either true or false).\"), mdx(\"p\", null, \"Since I need to check every letter in the string for how many times it appears, I don't think there's an ideal way to do that if I confine myself to string methods. If I need to do something with every member of a collection (like every letter in a string), the most convenient thing is to represent that collection as an array. Since I have a string, I can make an array out of it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const letters = id.split('')\\n\")), mdx(\"p\", null, \"Now I have an array of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"letters\"), \", and I want to find whether any letter in that array appears twice. The Big Three methods for manipulating an array are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".map()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".filter()\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".reduce()\"), \", so I'll start by thinking about how they could help. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".map()\"), \" returns an array that's the same length as the array I start with, which doesn't seem useful to help count repeating elements. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".filter()\"), \" would return a new array with certain elements filtered out. Hey, if I filtered a letter out, and the new array is two elements shorter than the original array, then the letter must have appeared twice in the original array!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const appearTwice = letters.filter(letter => letter !== ...)\\n\")), mdx(\"p\", null, \"Wait a minute. Which letter do I filter? I said earlier that I have to check all of them, to see if any of them appear twice. For that, I can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".some()\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const appearTwice = letters.some(\\n  letterToFilter =>\\n    letters.filter(letter => letter !== letterToFilter).length ===\\n    letters.length - 2\\n)\\n\")), mdx(\"p\", null, \"With \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".some()\"), \", I can go through \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"letters\"), \" one at a time. Each letter becomes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"letterToFilter\"), \", and I use that in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".filter()\"), \" to see whether filtering out \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"letterToFilter\"), \" leaves me with an array that's two letters shorter than what I started with. If it ever does, then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"appearTwice\"), \" is true.\"), mdx(\"p\", null, \"Checking if a letter appears three times is almost exactly the same:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const appearThreeTimes = letters.some(\\n  letterToFilter =>\\n    letters.filter(letter => letter !== letterToFilter).length ===\\n    letters.length - 3\\n)\\n\")), mdx(\"p\", null, \"Let's see how to use those in the callback for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  const letters = id.split('')\\n  const appearTwice = letters.some(\\n    letterToFilter =>\\n      letters.filter(letter => letter !== letterToFilter).length ===\\n      letters.length - 2\\n  )\\n  if (appearTwice) {\\n    // increase the count of ids with repeat letters, stored in `total`\\n  }\\n  const appearThreeTimes = letters.some(\\n    letterToFilter =>\\n      letters.filter(letter => letter !== letterToFilter).length ===\\n      letters.length - 3\\n  )\\n  if (appearThreeTimes) {\\n    // increase the count of ids with letters that appear 3x, stored in `total`\\n  }\\n  return // an object to use for the next `total`\\n}, counts)\\n\")), mdx(\"p\", null, \"I'd like to reduce the duplication between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"appearTwice\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"appearThreeTimes\"), \", but first I'll complete the algorithm so I can make sure it runs properly. I have two comments where I need to increase the count of each kind of string I'm counting. I'm keeping track of those counts in the object\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"let counts = {\\n  countOfIdsWithLetterAppearingTwice: 0,\\n  countOfIdsWithLetterAppearingThreeTimes: 0,\\n}\\n\")), mdx(\"p\", null, \"Since I'm using that as the initial value, it gets inside the callback function under the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"total\"), \". I can get each count out of the object with destructuring:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  let {\\n    countOfIdsWithLetterAppearingTwice,\\n    countOfIdsWithLetterAppearingThreeTimes\\n  } = total\\n...\\n\\nThat provides me with two variables, `countOfIdsWithLetterAppearingTwice` and `countOfIdsWithLetterAppearingThreeTimes`. Then I can change those varibales in the conditionals:\\n\\n```javascript\\n  if (appearTwice) {\\n    countOfIdsWithLetterAppearingTwice += 1\\n  }\\n\")), mdx(\"p\", null, \"and use the varibles to make an object for the callback's return value:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"return {\\n  countOfIdsWithLetterAppearingTwice,\\n  countOfIdsWithLetterAppearingThreeTimes,\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  let {\\n    countOfIdsWithLetterAppearingTwice,\\n    countOfIdsWithLetterAppearingThreeTimes,\\n  } = total\\n  const letters = id.split('')\\n  const appearTwice = letters.some(\\n    letterToFilter =>\\n      letters.filter(letter => letter !== letterToFilter).length ===\\n      letters.length - 2\\n  )\\n  if (appearTwice) {\\n    countOfIdsWithLetterAppearingTwice += 1\\n  }\\n  const appearThreeTimes = letters.some(\\n    letterToFilter =>\\n      letters.filter(letter => letter !== letterToFilter).length ===\\n      letters.length - 3\\n  )\\n  if (appearThreeTimes) {\\n    countOfIdsWithLetterAppearingThreeTimes += 1\\n  }\\n  return {\\n    countOfIdsWithLetterAppearingTwice,\\n    countOfIdsWithLetterAppearingThreeTimes,\\n  }\\n}, counts)\\n\")), mdx(\"p\", null, \"That works! Now I can tidy up a bit. There's a lot of duplication between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"appearTwoTimes\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"appearThreeTimes\"), \"; they're identical except for the number. I can pull that out into a function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const appearNTimes = n =>\\n  letters.some(\\n    letterToFilter =>\\n      letters.filter(letter => letter !== letterToFilter).length ===\\n      letters.length - n\\n  )\\n\")), mdx(\"p\", null, \"That's a function that takes a single argument, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \", and returns all of the code that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"appearTwoTimes\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"appearThreeTimes\"), \" had in common. I can use the function to create those expressions:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const appearTwoTimes = appearNTimes(2)\\nconst appearThreeTimes = appearNTimes(3)\\n\")), mdx(\"p\", null, \"That slims things down:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const result = ids.reduce((total, id) => {\\n  let {\\n    countOfIdsWithLetterAppearingTwice,\\n    countOfIdsWithLetterAppearingThreeTimes,\\n  } = total\\n  const letters = id.split('')\\n  const appearNTimes = n =>\\n    letters.some(\\n      letterToFilter =>\\n        letters.filter(letter => letter !== letterToFilter).length ===\\n        letters.length - n\\n    )\\n  const appearTwice = appearNTimes(2)\\n  if (appearTwice) {\\n    countOfIdsWithLetterAppearingTwice += 1\\n  }\\n  const appearThreeTimes = appearNTimes(3)\\n  if (appearThreeTimes) {\\n    countOfIdsWithLetterAppearingThreeTimes += 1\\n  }\\n  return {\\n    countOfIdsWithLetterAppearingTwice,\\n    countOfIdsWithLetterAppearingThreeTimes,\\n  }\\n}, initial)\\n\")), mdx(\"p\", null, \"This could be refactored some more, but I tend to obsess over that kind of thing, and I haven't started on the day's second puzzle. The second puzzle is shorter to describe, both for the problem and the solution. The problem is to find two ids that are identical except for one letter, and then print out the letters those two ids have in common. On to the solution.\"), mdx(\"p\", null, \"Because I need to compare pairs of ids, I need to have two nested iterations, one inside the other (a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop inside another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop or a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".forEach()\"), \" inside another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".forEach()\"), \"). I don't want to compare \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"every\"), \" pair, though; when I find the two ids I want, I can stop. That's easier to do from inside a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop than from inside a call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".forEach()\"), \". I also don't want to compare any pair twice; once I compare the first to the second, I don't need to compare the second to the first. I have to make sure the second, inner \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop doesn't look at any elements that have already been looked at in the outer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop. To do that, I can have the inner loop's index start at the next number after whatever the outer loop's index's value is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    // compare one id to another\\n  }\\n}\\n\")), mdx(\"p\", null, \"The point of having those indexes is to identify two id values I want to compare:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    const [first, second] = [ids[outerIndex], ids[innerIndex]]\\n    // compare first to second\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now I want to compare the letters in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"first\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"second\"), \". That suggests more iteration. Since I want to compare the letters at the same position in both ids, I don't need more nesting; just one more \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop will do:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    const [first, second] = [ids[outerIndex], ids[innerIndex]]\\n    for (let sharedIndex = 0; sharedIndex < first.length; sharedIndex += 1) {\\n      // compare a letter in first to the letter at the same index in second\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"I'm interested in finding the two id values that are different at only one position. That means (a) I need to keep track of how many positions are different, and (b) once a pair is different at two positions, I can go on to the next pair. I can take care of (b) by adding to the innermost \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \" loop's condition:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    const [first, second] = [ids[outerIndex], ids[innerIndex]]\\n    let differenceCount = 0\\n    for (\\n      let sharedIndex = 0;\\n      sharedIndex < first.length && differenceCount < 2;\\n      sharedIndex += 1\\n    ) {\\n      if (first[sharedIndex] !== second[sharedIndex]) {\\n        differenceCount += 1\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"OK, we're comparing each pair of ids in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ids\"), \" array, counting how many letters are different in each pair, and bailing out of a comparison if the pair is different in more than one position. What if we make it all the way to the end of one pair of strings and they're different in only one position? We should break out of the loop. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" statement by itself isn't enough, because that will only break out of the inner loop. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" can be given the label of the block to break out of. That means we'll need to add a label to the outer block:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"outerLoop: for (let outerIndex = 0; outerIndex < ids.length; outerIndex += 1) {\\n  for (\\n    let innerIndex = outerIndex + 1;\\n    innerIndex < ids.length;\\n    innerIndex += 1\\n  ) {\\n    const [first, second] = [ids[outerIndex], ids[innerIndex]]\\n    let differenceCount = 0\\n    for (\\n      let sharedIndex = 0;\\n      sharedIndex < first.length && differenceCount < 2;\\n      sharedIndex += 1\\n    ) {\\n      if (first[sharedIndex] !== second[sharedIndex]) {\\n        differenceCount += 1\\n      }\\n    }\\n    if (differenceCount === 1) {\\n      console.log('found them!', first, second)\\n      break outerLoop\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Getting close! In a pinch, you could look closely at that console output and type out one of the ids without the letter that's different between the two. That's actually how I submitted my solution to Advent of Code. To be thorough, here are the last steps to get the whole problem solved by software. We'll need to identify the position at which the two ids are different, then log out one of the ids with that position removed:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"    let differenceCount = 0\\n    let position\\n    for (let sharedIndex = 0; sharedIndex < first.length && differenceCount < 2; sharedIndex += 1) {\\n      if (first[sharedIndex] !== second[sharedIndex]) {\\n        differenceCount += 1\\n        position = sharedIndex\\n      }\\n    }\\n    if (differenceCount === 1) {\\n      console.log(first.slice(0, position - 1) + first.slice(position + 1))\\n      break outerLoop\\n    }\\n\")), mdx(\"p\", null, \"Tada!\"), mdx(\"p\", null, \"BTW to be completely thorough, I should mention that with the fairly small amount of data involved in this problem, none of the optimizations I added matter. Running the code as above takes ~20ms. Changing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"innerIndex\"), \" to start at 0 instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"outerIndex + 1\"), \", changing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sharedIndex\"), \" conditional to not look at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"differenceCount\"), \", and removing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"break\"), \" statement slows it down to...~60ms.\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"4c59a18d-07b7-5328-ba62-36051155f98d","slug":"/advent-of-code-day-2","frontMatter":{"path":"/advent-of-code-day-2","title":"2018 Advent of Code, Day 2","tags":["education","javascript","Advent of Code"]},"prev":{"id":"669d3616-8c2d-5cda-b661-db2476522aae","parent":{"name":"2018-12-01-advent-of-code-day-1-part-2"},"code":{"scope":""},"frontmatter":{"path":"/advent-of-code-day-1-part-2","title":"Solving Problems with Code","tags":["education","javascript","Advent of Code"]}},"next":null}}